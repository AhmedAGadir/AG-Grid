{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar context_1 = require(\"../context/context\");\n\nvar sortController_1 = require(\"../sortController\");\n\nvar utils_1 = require(\"../utils\");\n\nvar valueService_1 = require(\"../valueService/valueService\");\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar columnController_1 = require(\"../columnController/columnController\");\n\nvar SortService =\n/** @class */\nfunction () {\n  function SortService() {}\n\n  SortService.prototype.init = function () {\n    this.postSortFunc = this.gridOptionsWrapper.getPostSortFunc();\n  };\n\n  SortService.prototype.sortAccordingToColumnsState = function (rowNode) {\n    var sortOptions = this.sortController.getSortForRowController();\n    this.sort(rowNode, sortOptions);\n  };\n\n  SortService.prototype.sort = function (rowNode, sortOptions) {\n    var _this = this;\n\n    rowNode.childrenAfterSort = rowNode.childrenAfterFilter.slice(0); // we clear out the 'pull down open parents' first, as the values mix up the sorting\n\n    this.pullDownDataForHideOpenParents(rowNode, true);\n    var sortActive = utils_1._.exists(sortOptions) && sortOptions.length > 0;\n\n    if (sortActive) {\n      // RE https://ag-grid.atlassian.net/browse/AG-444\n      //Javascript sort is non deterministic when all the array items are equals\n      //ie Comparator always returns 0, so if you want to ensure the array keeps its\n      //order, then you need to add an additional sorting condition manually, in this\n      //case we are going to inspect the original array position\n      var sortedRowNodes = rowNode.childrenAfterSort.map(function (it, pos) {\n        return {\n          currentPos: pos,\n          rowNode: it\n        };\n      });\n      sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));\n      rowNode.childrenAfterSort = sortedRowNodes.map(function (sorted) {\n        return sorted.rowNode;\n      });\n    }\n\n    this.updateChildIndexes(rowNode);\n    this.pullDownDataForHideOpenParents(rowNode, false); // sort any groups recursively\n\n    rowNode.childrenAfterFilter.forEach(function (child) {\n      if (child.hasChildren()) {\n        _this.sort(child, sortOptions);\n      }\n    });\n\n    if (this.postSortFunc) {\n      this.postSortFunc(rowNode.childrenAfterSort);\n    }\n  };\n\n  SortService.prototype.compareRowNodes = function (sortOptions, sortedNodeA, sortedNodeB) {\n    var nodeA = sortedNodeA.rowNode;\n    var nodeB = sortedNodeB.rowNode; // Iterate columns, return the first that doesn't match\n\n    for (var i = 0, len = sortOptions.length; i < len; i++) {\n      var sortOption = sortOptions[i]; // let compared = compare(nodeA, nodeB, sortOption.column, sortOption.inverter === -1);\n\n      var isInverted = sortOption.inverter === -1;\n      var valueA = this.getValue(nodeA, sortOption.column);\n      var valueB = this.getValue(nodeB, sortOption.column);\n      var comparatorResult = void 0;\n\n      if (sortOption.column.getColDef().comparator) {\n        //if comparator provided, use it\n        comparatorResult = sortOption.column.getColDef().comparator(valueA, valueB, nodeA, nodeB, isInverted);\n      } else {\n        //otherwise do our own comparison\n        comparatorResult = utils_1._.defaultComparator(valueA, valueB, this.gridOptionsWrapper.isAccentedSort());\n      }\n\n      if (comparatorResult !== 0) {\n        return comparatorResult * sortOption.inverter;\n      }\n    } // All matched, we make is so that the original sort order is kept:\n\n\n    return sortedNodeA.currentPos - sortedNodeB.currentPos;\n  };\n\n  SortService.prototype.getValue = function (nodeA, column) {\n    return this.valueService.getValue(column, nodeA);\n  };\n\n  SortService.prototype.updateChildIndexes = function (rowNode) {\n    if (utils_1._.missing(rowNode.childrenAfterSort)) {\n      return;\n    }\n\n    rowNode.childrenAfterSort.forEach(function (child, index) {\n      var firstChild = index === 0;\n      var lastChild = index === rowNode.childrenAfterSort.length - 1;\n      child.setFirstChild(firstChild);\n      child.setLastChild(lastChild);\n      child.setChildIndex(index);\n    });\n  };\n\n  SortService.prototype.pullDownDataForHideOpenParents = function (rowNode, clearOperation) {\n    var _this = this;\n\n    if (utils_1._.missing(rowNode.childrenAfterSort)) {\n      return;\n    }\n\n    if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {\n      return;\n    }\n\n    rowNode.childrenAfterSort.forEach(function (childRowNode) {\n      var groupDisplayCols = _this.columnController.getGroupDisplayColumns();\n\n      groupDisplayCols.forEach(function (groupDisplayCol) {\n        var showRowGroup = groupDisplayCol.getColDef().showRowGroup;\n\n        if (typeof showRowGroup !== 'string') {\n          console.error('ag-Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup');\n          return;\n        }\n\n        var displayingGroupKey = showRowGroup;\n\n        var rowGroupColumn = _this.columnController.getPrimaryColumn(displayingGroupKey);\n\n        var thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;\n\n        if (thisRowNodeMatches) {\n          return;\n        }\n\n        if (clearOperation) {\n          // if doing a clear operation, we clear down the value for every possible group column\n          childRowNode.setGroupValue(groupDisplayCol.getId(), null);\n        } else {\n          // if doing a set operation, we set only where the pull down is to occur\n          var parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);\n\n          if (parentToStealFrom) {\n            childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);\n          }\n        }\n      });\n    });\n  };\n\n  __decorate([context_1.Autowired('sortController'), __metadata(\"design:type\", sortController_1.SortController)], SortService.prototype, \"sortController\", void 0);\n\n  __decorate([context_1.Autowired('columnController'), __metadata(\"design:type\", columnController_1.ColumnController)], SortService.prototype, \"columnController\", void 0);\n\n  __decorate([context_1.Autowired('valueService'), __metadata(\"design:type\", valueService_1.ValueService)], SortService.prototype, \"valueService\", void 0);\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], SortService.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], SortService.prototype, \"init\", null);\n\n  SortService = __decorate([context_1.Bean('sortService')], SortService);\n  return SortService;\n}();\n\nexports.SortService = SortService;","map":null,"metadata":{},"sourceType":"script"}