{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar columnGroup_1 = require(\"../entities/columnGroup\");\n\nvar originalColumnGroup_1 = require(\"../entities/originalColumnGroup\");\n\nvar context_1 = require(\"../context/context\");\n\nvar context_2 = require(\"../context/context\"); // takes in a list of columns, as specified by the column definitions, and returns column groups\n\n\nvar ColumnUtils =\n/** @class */\nfunction () {\n  function ColumnUtils() {}\n\n  ColumnUtils.prototype.calculateColInitialWidth = function (colDef) {\n    if (!colDef.width) {\n      // if no width defined in colDef, use default\n      return this.gridOptionsWrapper.getColWidth();\n    } else if (colDef.width < this.gridOptionsWrapper.getMinColWidth()) {\n      // if width in col def to small, set to min width\n      return this.gridOptionsWrapper.getMinColWidth();\n    } else {\n      // otherwise use the provided width\n      return colDef.width;\n    }\n  };\n\n  ColumnUtils.prototype.getOriginalPathForColumn = function (column, originalBalancedTree) {\n    var result = [];\n    var found = false;\n    recursePath(originalBalancedTree, 0); // we should always find the path, but in case there is a bug somewhere, returning null\n    // will make it fail rather than provide a 'hard to track down' bug\n\n    if (found) {\n      return result;\n    } else {\n      return null;\n    }\n\n    function recursePath(balancedColumnTree, dept) {\n      for (var i = 0; i < balancedColumnTree.length; i++) {\n        if (found) {\n          // quit the search, so 'result' is kept with the found result\n          return;\n        }\n\n        var node = balancedColumnTree[i];\n\n        if (node instanceof originalColumnGroup_1.OriginalColumnGroup) {\n          var nextNode = node;\n          recursePath(nextNode.getChildren(), dept + 1);\n          result[dept] = node;\n        } else {\n          if (node === column) {\n            found = true;\n          }\n        }\n      }\n    }\n  };\n  /*    public getPathForColumn(column: Column, allDisplayedColumnGroups: ColumnGroupChild[]): ColumnGroup[] {\n          let result: ColumnGroup[] = [];\n          let found = false;\n  \n          recursePath(allDisplayedColumnGroups, 0);\n  \n          // we should always find the path, but in case there is a bug somewhere, returning null\n          // will make it fail rather than provide a 'hard to track down' bug\n          if (found) {\n              return result;\n          } else {\n              return null;\n          }\n  \n          function recursePath(balancedColumnTree: ColumnGroupChild[], dept: number): void {\n  \n              for (let i = 0; i<balancedColumnTree.length; i++) {\n                  if (found) {\n                      // quit the search, so 'result' is kept with the found result\n                      return;\n                  }\n                  let node = balancedColumnTree[i];\n                  if (node instanceof ColumnGroup) {\n                      let nextNode = <ColumnGroup> node;\n                      recursePath(nextNode.getChildren(), dept+1);\n                      result[dept] = node;\n                  } else {\n                      if (node === column) {\n                          found = true;\n                      }\n                  }\n              }\n          }\n      }*/\n\n\n  ColumnUtils.prototype.depthFirstOriginalTreeSearch = function (tree, callback) {\n    var _this = this;\n\n    if (!tree) {\n      return;\n    }\n\n    tree.forEach(function (child) {\n      if (child instanceof originalColumnGroup_1.OriginalColumnGroup) {\n        _this.depthFirstOriginalTreeSearch(child.getChildren(), callback);\n      }\n\n      callback(child);\n    });\n  };\n\n  ColumnUtils.prototype.depthFirstAllColumnTreeSearch = function (tree, callback) {\n    var _this = this;\n\n    if (!tree) {\n      return;\n    }\n\n    tree.forEach(function (child) {\n      if (child instanceof columnGroup_1.ColumnGroup) {\n        _this.depthFirstAllColumnTreeSearch(child.getChildren(), callback);\n      }\n\n      callback(child);\n    });\n  };\n\n  ColumnUtils.prototype.depthFirstDisplayedColumnTreeSearch = function (tree, callback) {\n    var _this = this;\n\n    if (!tree) {\n      return;\n    }\n\n    tree.forEach(function (child) {\n      if (child instanceof columnGroup_1.ColumnGroup) {\n        _this.depthFirstDisplayedColumnTreeSearch(child.getDisplayedChildren(), callback);\n      }\n\n      callback(child);\n    });\n  };\n\n  __decorate([context_2.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], ColumnUtils.prototype, \"gridOptionsWrapper\", void 0);\n\n  ColumnUtils = __decorate([context_1.Bean('columnUtils')], ColumnUtils);\n  return ColumnUtils;\n}();\n\nexports.ColumnUtils = ColumnUtils;","map":null,"metadata":{},"sourceType":"script"}