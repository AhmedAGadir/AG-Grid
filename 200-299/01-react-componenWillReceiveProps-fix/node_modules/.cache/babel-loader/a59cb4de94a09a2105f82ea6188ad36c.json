{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"../utils\");\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar columnController_1 = require(\"../columnController/columnController\");\n\nvar columnApi_1 = require(\"../columnController/columnApi\");\n\nvar rowRenderer_1 = require(\"../rendering/rowRenderer\");\n\nvar context_1 = require(\"../context/context\");\n\nvar eventService_1 = require(\"../eventService\");\n\nvar events_1 = require(\"../events\");\n\nvar dragService_1 = require(\"../dragAndDrop/dragService\");\n\nvar constants_1 = require(\"../constants\");\n\nvar selectionController_1 = require(\"../selectionController\");\n\nvar csvCreator_1 = require(\"../exporter/csvCreator\");\n\nvar mouseEventService_1 = require(\"./mouseEventService\");\n\nvar focusedCellController_1 = require(\"../focusedCellController\");\n\nvar scrollVisibleService_1 = require(\"./scrollVisibleService\");\n\nvar rowContainerComponent_1 = require(\"../rendering/rowContainerComponent\");\n\nvar paginationProxy_1 = require(\"../rowModels/paginationProxy\");\n\nvar popupEditorWrapper_1 = require(\"../rendering/cellEditors/popupEditorWrapper\");\n\nvar alignedGridsService_1 = require(\"../alignedGridsService\");\n\nvar pinnedRowModel_1 = require(\"../rowModels/pinnedRowModel\");\n\nvar gridApi_1 = require(\"../gridApi\");\n\nvar animationFrameService_1 = require(\"../misc/animationFrameService\");\n\nvar rowComp_1 = require(\"../rendering/rowComp\");\n\nvar navigationService_1 = require(\"./navigationService\");\n\nvar valueService_1 = require(\"../valueService/valueService\");\n\nvar touchListener_1 = require(\"../widgets/touchListener\");\n\nvar componentRecipes_1 = require(\"../components/framework/componentRecipes\");\n\nvar dragAndDropService_1 = require(\"../dragAndDrop/dragAndDropService\");\n\nvar rowDragFeature_1 = require(\"./rowDragFeature\");\n\nvar heightScaler_1 = require(\"../rendering/heightScaler\");\n\nvar component_1 = require(\"../widgets/component\");\n\nvar autoHeightCalculator_1 = require(\"../rendering/autoHeightCalculator\");\n\nvar columnAnimationService_1 = require(\"../rendering/columnAnimationService\");\n\nvar autoWidthCalculator_1 = require(\"../rendering/autoWidthCalculator\");\n\nvar beans_1 = require(\"../rendering/beans\");\n\nvar componentAnnotations_1 = require(\"../widgets/componentAnnotations\");\n\nvar headerRootComp_1 = require(\"../headerRendering/headerRootComp\");\n\nvar resizeObserverService_1 = require(\"../misc/resizeObserverService\"); // in the html below, it is important that there are no white space between some of the divs, as if there is white space,\n// it won't render correctly in safari, as safari renders white space as a gap\n\n\nvar GRID_PANEL_NORMAL_TEMPLATE = \"<div class=\\\"ag-root ag-font-style\\\" role=\\\"grid\\\" unselectable=\\\"on\\\">\\n        <ag-header-root ref=\\\"headerRoot\\\" unselectable=\\\"on\\\"></ag-header-root>\\n        <div class=\\\"ag-floating-top\\\" ref=\\\"eTop\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n            <div class=\\\"ag-pinned-left-floating-top\\\" ref=\\\"eLeftTop\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            <div class=\\\"ag-floating-top-viewport\\\" ref=\\\"eTopViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-floating-top-container\\\" ref=\\\"eTopContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            </div>\\n            <div class=\\\"ag-pinned-right-floating-top\\\" ref=\\\"eRightTop\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            <div class=\\\"ag-floating-top-full-width-container\\\" ref=\\\"eTopFullWidthContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n        </div>\\n        <div class=\\\"ag-body\\\" ref=\\\"eBody\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n            <div class=\\\"ag-pinned-left-cols-viewport-wrapper\\\" ref=\\\"eLeftViewportWrapper\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-pinned-left-cols-viewport\\\" ref=\\\"eLeftViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                    <div class=\\\"ag-pinned-left-cols-container\\\" ref=\\\"eLeftContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n                </div>\\n            </div>\\n            <div class=\\\"ag-body-viewport-wrapper\\\" ref=\\\"eBodyViewportWrapper\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-body-viewport\\\" ref=\\\"eBodyViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                    <div class=\\\"ag-body-container\\\" ref=\\\"eBodyContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n                </div>\\n            </div>\\n            <div class=\\\"ag-pinned-right-cols-viewport-wrapper\\\" ref=\\\"eRightViewportWrapper\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-pinned-right-cols-viewport\\\" ref=\\\"eRightViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                    <div class=\\\"ag-pinned-right-cols-container\\\" ref=\\\"eRightContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n                </div>\\n            </div>\\n            <div class=\\\"ag-full-width-viewport-wrapper\\\" ref=\\\"eFullWidthViewportWrapper\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-full-width-viewport\\\" ref=\\\"eFullWidthViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                    <div class=\\\"ag-full-width-container\\\" ref=\\\"eFullWidthContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n                </div>\\n            </div>\\n        </div>\\n        <div class=\\\"ag-floating-bottom\\\" ref=\\\"eBottom\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n            <div class=\\\"ag-pinned-left-floating-bottom\\\" ref=\\\"eLeftBottom\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            <div class=\\\"ag-floating-bottom-viewport\\\" ref=\\\"eBottomViewport\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\">\\n                <div class=\\\"ag-floating-bottom-container\\\" ref=\\\"eBottomContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            </div>\\n            <div class=\\\"ag-pinned-right-floating-bottom\\\" ref=\\\"eRightBottom\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n            <div class=\\\"ag-floating-bottom-full-width-container\\\" ref=\\\"eBottomFullWidthContainer\\\" role=\\\"presentation\\\" unselectable=\\\"on\\\"></div>\\n        </div>\\n        <div class=\\\"ag-overlay\\\" ref=\\\"eOverlay\\\"></div>\\n    </div>\";\n\nvar GridPanel =\n/** @class */\nfunction (_super) {\n  __extends(GridPanel, _super);\n\n  function GridPanel() {\n    var _this = _super.call(this, GRID_PANEL_NORMAL_TEMPLATE) || this;\n\n    _this.scrollLeft = -1;\n    _this.nextScrollLeft = -1;\n    _this.scrollTop = -1;\n    _this.nextScrollTop = -1;\n    _this.verticalRedrawNeeded = false;\n    _this.recentScrolls = {};\n    return _this;\n  }\n\n  GridPanel.prototype.getVScrollPosition = function () {\n    var result = {\n      top: this.eBodyViewport.scrollTop,\n      bottom: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight\n    };\n    return result;\n  }; // used by range controller\n\n\n  GridPanel.prototype.getHScrollPosition = function () {\n    var result = {\n      left: this.eBodyViewport.scrollLeft,\n      right: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetWidth\n    };\n    return result;\n  }; // we override this, as the base class is missing the annotation\n\n\n  GridPanel.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n  };\n\n  GridPanel.prototype.onRowDataChanged = function () {\n    this.showOrHideOverlay();\n  };\n\n  GridPanel.prototype.showOrHideOverlay = function () {\n    if (this.paginationProxy.isEmpty() && !this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {\n      this.showNoRowsOverlay();\n    } else {\n      this.hideOverlay();\n    }\n  };\n\n  GridPanel.prototype.onNewColumnsLoaded = function () {\n    // hide overlay if columns and rows exist, this can happen if columns are loaded after data.\n    // this problem exists before of the race condition between the services (column controller in this case)\n    // and the view (grid panel). if the model beans were all initialised first, and then the view beans second,\n    // this race condition would not happen.\n    if (this.columnController.isReady() && !this.paginationProxy.isEmpty()) {\n      this.hideOverlay();\n    }\n  };\n\n  GridPanel.prototype.init = function () {\n    this.instantiate(this.context);\n    this.scrollWidth = this.gridOptionsWrapper.getScrollbarWidth();\n    this.enableRtl = this.gridOptionsWrapper.isEnableRtl();\n    this.useAnimationFrame = !this.gridOptionsWrapper.isSuppressAnimationFrame();\n    this.printLayout = this.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_PRINT; // if the browser is Windows based, then the scrollbars take up space, and we clip by\n    // the width of the scrollbar. however if the scroll bars do not take up space (iOS)\n    // then they overlay on top of the div, so we clip some extra blank space instead.\n\n    this.scrollClipWidth = this.scrollWidth > 0 ? this.scrollWidth : 20; // all of these element have different CSS when layout changes\n\n    this.gridOptionsWrapper.addLayoutElement(this.getGui());\n    this.gridOptionsWrapper.addLayoutElement(this.eBody);\n    this.gridOptionsWrapper.addLayoutElement(this.eBodyViewport);\n    this.gridOptionsWrapper.addLayoutElement(this.eTopViewport);\n    this.gridOptionsWrapper.addLayoutElement(this.eBodyContainer);\n    this.gridOptionsWrapper.addLayoutElement(this.eBodyViewportWrapper);\n    this.suppressScrollOnFloatingRow();\n    this.setupRowAnimationCssClass();\n    this.buildRowContainerComponents();\n    this.addEventListeners();\n    this.addDragListeners();\n    this.addScrollListener();\n\n    if (this.gridOptionsWrapper.isSuppressHorizontalScroll()) {\n      this.eBodyViewport.style.overflowX = 'hidden';\n    }\n\n    this.setupOverlay();\n\n    if (this.gridOptionsWrapper.isRowModelDefault() && !this.gridOptionsWrapper.getRowData()) {\n      this.showLoadingOverlay();\n    }\n\n    this.setPinnedContainersVisible();\n    this.setBodyAndHeaderHeights();\n    this.disableBrowserDragging();\n    this.addShortcutKeyListeners();\n    this.addMouseListeners();\n    this.addKeyboardEvents();\n    this.addBodyViewportListener();\n    this.addStopEditingWhenGridLosesFocus();\n    this.mockContextMenuForIPad();\n    this.addRowDragListener();\n\n    if (this.$scope) {\n      this.addAngularApplyCheck();\n    }\n\n    this.onDisplayedColumnsWidthChanged(); // this.addWindowResizeListener();\n\n    this.gridApi.registerGridComp(this);\n    this.alignedGridsService.registerGridComp(this);\n    this.headerRootComp.registerGridComp(this);\n    this.animationFrameService.registerGridComp(this);\n    this.navigationService.registerGridComp(this);\n    this.heightScaler.registerGridComp(this);\n    this.autoHeightCalculator.registerGridComp(this);\n    this.columnAnimationService.registerGridComp(this);\n    this.autoWidthCalculator.registerGridComp(this);\n    this.paginationAutoPageSizeService.registerGridComp(this);\n    this.beans.registerGridComp(this);\n    this.rowRenderer.registerGridComp(this);\n\n    if (this.rangeController) {\n      this.rangeController.registerGridComp(this);\n    }\n\n    var unsubscribeFromResize = this.resizeObserverService.observeResize(this.eBodyViewport, this.onBodyViewportResized.bind(this));\n    this.addDestroyFunc(function () {\n      return unsubscribeFromResize();\n    });\n  };\n\n  GridPanel.prototype.onDomLayoutChanged = function () {\n    var newPrintLayout = this.gridOptionsWrapper.getDomLayout() === constants_1.Constants.DOM_LAYOUT_PRINT;\n\n    if (this.printLayout !== newPrintLayout) {\n      this.printLayout = newPrintLayout;\n      this.setWidthsOfContainers(); // pinned containers are always hidden for print layout\n\n      this.setPinnedContainersVisible(); // in case we have margins for hiding the scroll on body, this takes them out\n\n      this.hideVerticalScrollOnCenter();\n    }\n  };\n\n  GridPanel.prototype.onBodyViewportResized = function () {\n    this.checkViewportAndScrolls();\n  }; // used by ColumnAnimationService\n\n\n  GridPanel.prototype.setColumnMovingCss = function (moving) {\n    this.addOrRemoveCssClass('ag-column-moving', moving);\n  };\n\n  GridPanel.prototype.setupOverlay = function () {\n    this.overlayWrapper = this.componentRecipes.newOverlayWrapperComponent();\n    this.eOverlay = this.queryForHtmlElement('[ref=\"eOverlay\"]');\n    this.overlayWrapper.hideOverlay(this.eOverlay);\n  };\n\n  GridPanel.prototype.addRowDragListener = function () {\n    var rowDragFeature = new rowDragFeature_1.RowDragFeature(this.eBody, this);\n    this.context.wireBean(rowDragFeature);\n    this.dragAndDropService.addDropTarget(rowDragFeature);\n  };\n\n  GridPanel.prototype.addStopEditingWhenGridLosesFocus = function () {\n    var _this = this;\n\n    if (!this.gridOptionsWrapper.isStopEditingWhenGridLosesFocus()) {\n      return;\n    }\n\n    var focusOutListener = function focusOutListener(event) {\n      // this is the element the focus is moving to\n      var elementWithFocus = event.relatedTarget; // see if the element the focus is going to is part of the grid\n\n      var clickInsideGrid = false;\n      var pointer = elementWithFocus;\n\n      while (utils_1.Utils.exists(pointer) && !clickInsideGrid) {\n        var isPopup = !!_this.gridOptionsWrapper.getDomData(pointer, popupEditorWrapper_1.PopupEditorWrapper.DOM_KEY_POPUP_EDITOR_WRAPPER);\n        var isBody = _this.eBody === pointer || _this.eBottom === pointer || _this.eTop === pointer;\n        clickInsideGrid = isPopup || isBody;\n        pointer = pointer.parentNode;\n      }\n\n      if (!clickInsideGrid) {\n        _this.rowRenderer.stopEditing();\n      }\n    };\n\n    this.addDestroyableEventListener(this.eBody, 'focusout', focusOutListener);\n    this.addDestroyableEventListener(this.eTop, 'focusout', focusOutListener);\n    this.addDestroyableEventListener(this.eBottom, 'focusout', focusOutListener);\n  };\n\n  GridPanel.prototype.addAngularApplyCheck = function () {\n    var _this = this; // this makes sure if we queue up requests, we only execute oe\n\n\n    var applyTriggered = false;\n\n    var listener = function listener() {\n      // only need to do one apply at a time\n      if (applyTriggered) {\n        return;\n      }\n\n      applyTriggered = true; // mark 'need apply' to true\n\n      setTimeout(function () {\n        applyTriggered = false;\n\n        _this.$scope.$apply();\n      }, 0);\n    }; // these are the events we need to do an apply after - these are the ones that can end up\n    // with columns added or removed\n\n\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, listener);\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_VIRTUAL_COLUMNS_CHANGED, listener);\n  }; // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)\n  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.\n\n\n  GridPanel.prototype.disableBrowserDragging = function () {\n    this.addGuiEventListener('dragstart', function (event) {\n      if (event.target instanceof HTMLImageElement) {\n        event.preventDefault();\n        return false;\n      }\n    });\n  };\n\n  GridPanel.prototype.addEventListeners = function () {\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_PINNED_ROW_DATA_CHANGED, this.setBodyAndHeaderHeights.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_ROW_DATA_CHANGED, this.onRowDataChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_ROW_DATA_UPDATED, this.onRowDataChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));\n    this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));\n    this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_PIVOT_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));\n    this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_GROUP_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));\n    this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_PIVOT_GROUP_HEADER_HEIGHT, this.setBodyAndHeaderHeights.bind(this));\n    this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_FLOATING_FILTERS_HEIGHT, this.setBodyAndHeaderHeights.bind(this));\n    this.addDestroyableEventListener(this.gridOptionsWrapper, gridOptionsWrapper_1.GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n  };\n\n  GridPanel.prototype.addDragListeners = function () {\n    var _this = this;\n\n    if (!this.gridOptionsWrapper.isEnableRangeSelection() // no range selection if no property\n    || utils_1.Utils.missing(this.rangeController)) {\n      // no range selection if not enterprise version\n      return;\n    }\n\n    var containers = [this.eLeftContainer, this.eRightContainer, this.eBodyContainer, this.eTop, this.eBottom];\n    containers.forEach(function (container) {\n      var params = {\n        eElement: container,\n        onDragStart: _this.rangeController.onDragStart.bind(_this.rangeController),\n        onDragStop: _this.rangeController.onDragStop.bind(_this.rangeController),\n        onDragging: _this.rangeController.onDragging.bind(_this.rangeController),\n        // for range selection by dragging the mouse, we want to ignore the event if shift key is pressed,\n        // as shift key click is another type of range selection\n        skipMouseEvent: function skipMouseEvent(mouseEvent) {\n          return mouseEvent.shiftKey;\n        }\n      };\n\n      _this.dragService.addDragSource(params);\n\n      _this.addDestroyFunc(function () {\n        return _this.dragService.removeDragSource(params);\n      });\n    });\n  };\n\n  GridPanel.prototype.addMouseListeners = function () {\n    var _this = this;\n\n    var eventNames = ['click', 'mousedown', 'dblclick', 'contextmenu', 'mouseover', 'mouseout'];\n    eventNames.forEach(function (eventName) {\n      var listener = _this.processMouseEvent.bind(_this, eventName);\n\n      _this.eAllCellContainers.forEach(function (container) {\n        return _this.addDestroyableEventListener(container, eventName, listener);\n      });\n    });\n  };\n\n  GridPanel.prototype.addKeyboardEvents = function () {\n    var _this = this;\n\n    var eventNames = ['keydown', 'keypress'];\n    eventNames.forEach(function (eventName) {\n      var listener = _this.processKeyboardEvent.bind(_this, eventName);\n\n      _this.eAllCellContainers.forEach(function (container) {\n        _this.addDestroyableEventListener(container, eventName, listener);\n      });\n    });\n  };\n\n  GridPanel.prototype.addBodyViewportListener = function () {\n    var _this = this; // we want to listen for clicks directly on the eBodyViewport, so the user has a way of showing\n    // the context menu if no rows are displayed, or user simply clicks outside of a cell\n\n\n    var listener = function listener(mouseEvent) {\n      var target = utils_1.Utils.getTarget(mouseEvent);\n\n      if (target === _this.eBodyViewport || target === _this.eLeftViewport || target === _this.eRightViewport) {\n        // show it\n        _this.onContextMenu(mouseEvent, null, null, null, null);\n\n        _this.preventDefaultOnContextMenu(mouseEvent);\n      }\n    }; //For some reason listening only to this.eBody doesnt work... Maybe because the event is consumed somewhere else?\n    //In any case, not expending much time on this, if anyome comes accross this and knows how to make this work with\n    //one listener please go ahead and change it...\n\n\n    this.addDestroyableEventListener(this.eBodyViewport, 'contextmenu', listener);\n    this.addDestroyableEventListener(this.eRightViewport, 'contextmenu', listener);\n    this.addDestroyableEventListener(this.eLeftViewport, 'contextmenu', listener);\n  }; // + rangeController\n\n\n  GridPanel.prototype.getBodyClientRect = function () {\n    if (this.eBody) {\n      return this.eBody.getBoundingClientRect();\n    }\n  };\n\n  GridPanel.prototype.getRowForEvent = function (event) {\n    var sourceElement = utils_1.Utils.getTarget(event);\n\n    while (sourceElement) {\n      var renderedRow = this.gridOptionsWrapper.getDomData(sourceElement, rowComp_1.RowComp.DOM_DATA_KEY_RENDERED_ROW);\n\n      if (renderedRow) {\n        return renderedRow;\n      }\n\n      sourceElement = sourceElement.parentElement;\n    }\n\n    return null;\n  };\n\n  GridPanel.prototype.processKeyboardEvent = function (eventName, keyboardEvent) {\n    var renderedCell = this.mouseEventService.getRenderedCellForEvent(keyboardEvent);\n\n    if (!renderedCell) {\n      return;\n    }\n\n    switch (eventName) {\n      case 'keydown':\n        // first see if it's a scroll key, page up / down, home / end etc\n        var wasScrollKey = this.navigationService.handlePageScrollingKey(keyboardEvent); // if not a scroll key, then we pass onto cell\n\n        if (!wasScrollKey) {\n          renderedCell.onKeyDown(keyboardEvent);\n        }\n\n        break;\n\n      case 'keypress':\n        renderedCell.onKeyPress(keyboardEvent);\n        break;\n    }\n  }; // gets called by rowRenderer when new data loaded, as it will want to scroll to the top\n\n\n  GridPanel.prototype.scrollToTop = function () {\n    this.eBodyViewport.scrollTop = 0;\n  };\n\n  GridPanel.prototype.processMouseEvent = function (eventName, mouseEvent) {\n    if (!this.mouseEventService.isEventFromThisGrid(mouseEvent)) {\n      return;\n    }\n\n    if (utils_1.Utils.isStopPropagationForAgGrid(mouseEvent)) {\n      return;\n    }\n\n    var rowComp = this.getRowForEvent(mouseEvent);\n    var cellComp = this.mouseEventService.getRenderedCellForEvent(mouseEvent);\n\n    if (eventName === \"contextmenu\") {\n      this.handleContextMenuMouseEvent(mouseEvent, null, rowComp, cellComp);\n    } else {\n      if (cellComp) {\n        cellComp.onMouseEvent(eventName, mouseEvent);\n      }\n\n      if (rowComp) {\n        rowComp.onMouseEvent(eventName, mouseEvent);\n      }\n    }\n\n    this.preventDefaultOnContextMenu(mouseEvent);\n  };\n\n  GridPanel.prototype.mockContextMenuForIPad = function () {\n    var _this = this; // we do NOT want this when not in ipad, otherwise we will be doing\n\n\n    if (!utils_1.Utils.isUserAgentIPad()) {\n      return;\n    }\n\n    this.eAllCellContainers.forEach(function (container) {\n      var touchListener = new touchListener_1.TouchListener(container);\n\n      var longTapListener = function longTapListener(event) {\n        var rowComp = _this.getRowForEvent(event.touchEvent);\n\n        var cellComp = _this.mouseEventService.getRenderedCellForEvent(event.touchEvent);\n\n        _this.handleContextMenuMouseEvent(null, event.touchEvent, rowComp, cellComp);\n      };\n\n      _this.addDestroyableEventListener(touchListener, touchListener_1.TouchListener.EVENT_LONG_TAP, longTapListener);\n\n      _this.addDestroyFunc(function () {\n        return touchListener.destroy();\n      });\n    });\n  };\n\n  GridPanel.prototype.handleContextMenuMouseEvent = function (mouseEvent, touchEvent, rowComp, cellComp) {\n    var rowNode = rowComp ? rowComp.getRowNode() : null;\n    var column = cellComp ? cellComp.getColumn() : null;\n    var value = null;\n\n    if (column) {\n      var event_1 = mouseEvent ? mouseEvent : touchEvent;\n      cellComp.dispatchCellContextMenuEvent(event_1);\n      value = this.valueService.getValue(column, rowNode);\n    }\n\n    this.onContextMenu(mouseEvent, touchEvent, rowNode, column, value);\n  };\n\n  GridPanel.prototype.onContextMenu = function (mouseEvent, touchEvent, rowNode, column, value) {\n    // to allow us to debug in chrome, we ignore the event if ctrl is pressed.\n    // not everyone wants this, so first 'if' below allows to turn this hack off.\n    if (!this.gridOptionsWrapper.isAllowContextMenuWithControlKey()) {\n      // then do the check\n      if (mouseEvent && (mouseEvent.ctrlKey || mouseEvent.metaKey)) {\n        return;\n      }\n    }\n\n    if (this.contextMenuFactory && !this.gridOptionsWrapper.isSuppressContextMenu()) {\n      var eventOrTouch = mouseEvent ? mouseEvent : touchEvent.touches[0];\n      this.contextMenuFactory.showMenu(rowNode, column, value, eventOrTouch);\n      var event_2 = mouseEvent ? mouseEvent : touchEvent;\n      event_2.preventDefault();\n    }\n  };\n\n  GridPanel.prototype.preventDefaultOnContextMenu = function (mouseEvent) {\n    // if we don't do this, then middle click will never result in a 'click' event, as 'mousedown'\n    // will be consumed by the browser to mean 'scroll' (as you can scroll with the middle mouse\n    // button in the browser). so this property allows the user to receive middle button clicks if\n    // they want.\n    if (this.gridOptionsWrapper.isSuppressMiddleClickScrolls() && mouseEvent.which === 2) {\n      mouseEvent.preventDefault();\n    }\n  };\n\n  GridPanel.prototype.addShortcutKeyListeners = function () {\n    var _this = this;\n\n    this.eAllCellContainers.forEach(function (container) {\n      _this.addDestroyableEventListener(container, 'keydown', function (event) {\n        // if the cell the event came from is editing, then we do not\n        // want to do the default shortcut keys, otherwise the editor\n        // (eg a text field) would not be able to do the normal cut/copy/paste\n        var renderedCell = _this.mouseEventService.getRenderedCellForEvent(event);\n\n        if (renderedCell && renderedCell.isEditing()) {\n          return;\n        } // for copy / paste, we don't want to execute when the event\n        // was from a child grid (happens in master detail)\n\n\n        if (!_this.mouseEventService.isEventFromThisGrid(event)) {\n          return;\n        }\n\n        if (event.ctrlKey || event.metaKey) {\n          switch (event.which) {\n            case constants_1.Constants.KEY_A:\n              return _this.onCtrlAndA(event);\n\n            case constants_1.Constants.KEY_C:\n              return _this.onCtrlAndC(event);\n\n            case constants_1.Constants.KEY_V:\n              return _this.onCtrlAndV(event);\n\n            case constants_1.Constants.KEY_D:\n              return _this.onCtrlAndD(event);\n          }\n        }\n      });\n    });\n  };\n\n  GridPanel.prototype.onCtrlAndA = function (event) {\n    if (this.rangeController && this.paginationProxy.isRowsToRender()) {\n      var rowEnd = void 0;\n      var floatingStart = void 0;\n      var floatingEnd = void 0;\n\n      if (this.pinnedRowModel.isEmpty(constants_1.Constants.PINNED_TOP)) {\n        floatingStart = null;\n      } else {\n        floatingStart = constants_1.Constants.PINNED_TOP;\n      }\n\n      if (this.pinnedRowModel.isEmpty(constants_1.Constants.PINNED_BOTTOM)) {\n        floatingEnd = null;\n        rowEnd = this.paginationProxy.getTotalRowCount() - 1;\n      } else {\n        floatingEnd = constants_1.Constants.PINNED_BOTTOM;\n        rowEnd = this.pinnedRowModel.getPinnedBottomRowData().length - 1;\n      }\n\n      var allDisplayedColumns = this.columnController.getAllDisplayedColumns();\n\n      if (utils_1.Utils.missingOrEmpty(allDisplayedColumns)) {\n        return;\n      }\n\n      this.rangeController.setRange({\n        rowStart: 0,\n        floatingStart: floatingStart,\n        rowEnd: rowEnd,\n        floatingEnd: floatingEnd,\n        columnStart: allDisplayedColumns[0],\n        columnEnd: allDisplayedColumns[allDisplayedColumns.length - 1]\n      });\n    }\n\n    event.preventDefault();\n    return false;\n  };\n\n  GridPanel.prototype.onCtrlAndC = function (event) {\n    if (!this.clipboardService) {\n      return;\n    }\n\n    var focusedCell = this.focusedCellController.getFocusedCell();\n    this.clipboardService.copyToClipboard();\n    event.preventDefault(); // the copy operation results in loosing focus on the cell,\n    // because of the trickery the copy logic uses with a temporary\n    // widget. so we set it back again.\n\n    if (focusedCell) {\n      this.focusedCellController.setFocusedCell(focusedCell.rowIndex, focusedCell.column, focusedCell.floating, true);\n    }\n\n    return false;\n  };\n\n  GridPanel.prototype.onCtrlAndV = function (event) {\n    if (!this.enterprise) {\n      return;\n    }\n\n    if (this.gridOptionsWrapper.isSuppressClipboardPaste()) {\n      return;\n    }\n\n    this.clipboardService.pasteFromClipboard();\n    return false;\n  };\n\n  GridPanel.prototype.onCtrlAndD = function (event) {\n    if (!this.enterprise) {\n      return;\n    }\n\n    this.clipboardService.copyRangeDown();\n    event.preventDefault();\n    return false;\n  }; // Valid values for position are bottom, middle and top\n  // position should be {'top','middle','bottom', or undefined/null}.\n  // if undefined/null, then the grid will to the minimal amount of scrolling,\n  // eg if grid needs to scroll up, it scrolls until row is on top,\n  //    if grid needs to scroll down, it scrolls until row is on bottom,\n  //    if row is already in view, grid does not scroll\n\n\n  GridPanel.prototype.ensureIndexVisible = function (index, position) {\n    // if for print or auto height, everything is always visible\n    if (this.printLayout) {\n      return;\n    }\n\n    var rowCount = this.paginationProxy.getTotalRowCount();\n\n    if (typeof index !== 'number' || index < 0 || index >= rowCount) {\n      console.warn('invalid row index for ensureIndexVisible: ' + index);\n      return;\n    }\n\n    this.paginationProxy.goToPageWithIndex(index);\n    var rowNode = this.paginationProxy.getRow(index);\n    var paginationOffset = this.paginationProxy.getPixelOffset();\n    var rowTopPixel = rowNode.rowTop - paginationOffset;\n    var rowBottomPixel = rowTopPixel + rowNode.rowHeight;\n    var scrollPosition = this.getVScrollPosition();\n    var heightOffset = this.heightScaler.getOffset();\n    var vScrollTop = scrollPosition.top + heightOffset;\n    var vScrollBottom = scrollPosition.bottom + heightOffset;\n\n    if (this.isHorizontalScrollShowing()) {\n      vScrollBottom -= this.scrollWidth;\n    }\n\n    var viewportHeight = vScrollBottom - vScrollTop;\n    var newScrollPosition = null; // work out the pixels for top, middle and bottom up front,\n    // make the if/else below easier to read\n\n    var pxTop = this.heightScaler.getScrollPositionForPixel(rowTopPixel);\n    var pxBottom = this.heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);\n    var pxMiddle = (pxTop + pxBottom) / 2; // make sure if middle, the row is not outside the top of the grid\n\n    if (pxMiddle > rowTopPixel) {\n      pxMiddle = rowTopPixel;\n    }\n\n    var rowBelowViewport = vScrollTop > rowTopPixel;\n    var rowAboveViewport = vScrollBottom < rowBottomPixel;\n\n    if (position === 'top') {\n      newScrollPosition = pxTop;\n    } else if (position === 'bottom') {\n      newScrollPosition = pxBottom;\n    } else if (position === 'middle') {\n      newScrollPosition = pxMiddle;\n    } else if (rowBelowViewport) {\n      // if row is before, scroll up with row at top\n      newScrollPosition = pxTop;\n    } else if (rowAboveViewport) {\n      // if row is below, scroll down with row at bottom\n      newScrollPosition = pxBottom;\n    }\n\n    if (newScrollPosition !== null) {\n      this.eBodyViewport.scrollTop = newScrollPosition;\n      this.rowRenderer.redrawAfterScroll();\n    } // so when we return back to user, the cells have rendered\n\n\n    this.animationFrameService.flushAllFrames();\n  }; // + moveColumnController\n\n\n  GridPanel.prototype.getCenterWidth = function () {\n    return this.eBodyViewport.clientWidth;\n  };\n\n  GridPanel.prototype.isHorizontalScrollShowing = function () {\n    return utils_1.Utils.isHorizontalScrollShowing(this.eBodyViewport);\n  };\n\n  GridPanel.prototype.isVerticalScrollShowing = function () {\n    return utils_1.Utils.isVerticalScrollShowing(this.eBodyViewport);\n  }; // gets called every time the viewport size changes. we use this to check visibility of scrollbars\n  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.\n\n\n  GridPanel.prototype.checkViewportAndScrolls = function () {\n    // results in updating anything that depends on scroll showing\n    this.updateScrollVisibleService(); // fires event if height changes, used by PaginationService, HeightScalerService, RowRenderer\n\n    this.checkBodyHeight(); // check for virtual columns for ColumnController\n\n    this.onHorizontalViewportChanged();\n    this.setPinnedLeftWidth();\n    this.setPinnedRightWidth();\n    this.setBottomPaddingOnPinned();\n    this.hideVerticalScrollOnCenter();\n    this.hideFullWidthViewportScrollbars();\n  };\n\n  GridPanel.prototype.updateScrollVisibleService = function () {\n    var params = {\n      bodyHorizontalScrollShowing: false,\n      leftVerticalScrollShowing: false,\n      rightVerticalScrollShowing: false\n    };\n\n    if (this.enableRtl && this.columnController.isPinningLeft()) {\n      params.leftVerticalScrollShowing = utils_1.Utils.isVerticalScrollShowing(this.eLeftViewport);\n    }\n\n    if (!this.enableRtl && this.columnController.isPinningRight()) {\n      params.rightVerticalScrollShowing = utils_1.Utils.isVerticalScrollShowing(this.eRightViewport);\n    }\n\n    params.bodyHorizontalScrollShowing = this.isHorizontalScrollShowing();\n    this.scrollVisibleService.setScrollsVisible(params);\n  }; // the pinned container needs extra space at the bottom, some blank space, otherwise when\n  // vertically scrolled all the way down, the last row will be hidden behind the scrolls.\n  // this extra padding allows the last row to be lifted above the bottom scrollbar.\n\n\n  GridPanel.prototype.setBottomPaddingOnPinned = function () {\n    // no need for padding if the scrollbars are not taking up any space\n    if (this.scrollWidth <= 0) {\n      return;\n    }\n\n    if (this.isHorizontalScrollShowing()) {\n      this.eRightContainer.style.marginBottom = this.scrollWidth + 'px';\n      this.eLeftContainer.style.marginBottom = this.scrollWidth + 'px';\n    } else {\n      this.eRightContainer.style.marginBottom = '';\n      this.eLeftContainer.style.marginBottom = '';\n    }\n  };\n\n  GridPanel.prototype.hideFullWidthViewportScrollbars = function () {\n    // if browser does not have scrollbars that take up space (eg iOS) then we don't need\n    // to adjust the sizes of the container for scrollbars\n    // if (this.scrollWidth <= 0) { return; }\n    var scrollWidthPx = this.scrollClipWidth > 0 ? this.scrollWidth + 'px' : ''; // if horizontal scroll is showing, we add padding to bottom so\n    // fullWidth container is not spreading over the scroll\n\n    this.eFullWidthViewportWrapper.style.paddingBottom = this.isHorizontalScrollShowing() ? scrollWidthPx : ''; // if vertical scroll is showing on full width viewport, then we clip it away, otherwise\n    // it competes with the main vertical scroll. this is done by getting the viewport to be\n    // bigger than the wrapper, the wrapper then ends up clipping the viewport.\n\n    var takeOutVScroll = this.isVerticalScrollShowing();\n\n    if (this.enableRtl) {\n      this.eFullWidthViewportWrapper.style.marginLeft = takeOutVScroll ? scrollWidthPx : '';\n      this.eFullWidthViewport.style.marginLeft = takeOutVScroll ? '-' + scrollWidthPx : '';\n    } else {\n      this.eFullWidthViewportWrapper.style.width = takeOutVScroll ? \"calc(100% - \" + scrollWidthPx + \")\" : '';\n      this.eFullWidthViewport.style.width = takeOutVScroll ? \"calc(100% + \" + scrollWidthPx + \")\" : '';\n    }\n  };\n\n  GridPanel.prototype.ensureColumnVisible = function (key) {\n    var column = this.columnController.getGridColumn(key);\n\n    if (!column) {\n      return;\n    }\n\n    if (column.isPinned()) {\n      console.warn('calling ensureIndexVisible on a ' + column.getPinned() + ' pinned column doesn\\'t make sense for column ' + column.getColId());\n      return;\n    }\n\n    if (!this.columnController.isColumnDisplayed(column)) {\n      console.warn('column is not currently visible');\n      return;\n    }\n\n    var colLeftPixel = column.getLeft();\n    var colRightPixel = colLeftPixel + column.getActualWidth();\n    var viewportWidth = this.eBodyViewport.clientWidth;\n    var scrollPosition = this.getBodyViewportScrollLeft();\n    var bodyWidth = this.columnController.getBodyContainerWidth();\n    var viewportLeftPixel;\n    var viewportRightPixel; // the logic of working out left and right viewport px is both here and in the ColumnController,\n    // need to refactor it out to one place\n\n    if (this.enableRtl) {\n      viewportLeftPixel = bodyWidth - scrollPosition - viewportWidth;\n      viewportRightPixel = bodyWidth - scrollPosition;\n    } else {\n      viewportLeftPixel = scrollPosition;\n      viewportRightPixel = viewportWidth + scrollPosition;\n    }\n\n    var viewportScrolledPastCol = viewportLeftPixel > colLeftPixel;\n    var viewportScrolledBeforeCol = viewportRightPixel < colRightPixel;\n    var colToSmallForViewport = viewportWidth < column.getActualWidth();\n    var alignColToLeft = viewportScrolledPastCol || colToSmallForViewport;\n    var alignColToRight = viewportScrolledBeforeCol;\n    var newScrollPosition = this.getBodyViewportScrollLeft();\n\n    if (alignColToLeft || alignColToRight) {\n      if (this.enableRtl) {\n        newScrollPosition = alignColToLeft ? bodyWidth - viewportWidth - colLeftPixel : bodyWidth - colRightPixel;\n      } else {\n        newScrollPosition = alignColToLeft ? colLeftPixel : colRightPixel - viewportWidth;\n      }\n\n      this.setBodyViewportScrollLeft(newScrollPosition);\n    } else {} // otherwise, col is already in view, so do nothing\n    // this will happen anyway, as the move will cause a 'scroll' event on the body, however\n    // it is possible that the ensureColumnVisible method is called from within ag-Grid and\n    // the caller will need to have the columns rendered to continue, which will be before\n    // the event has been worked on (which is the case for cell navigation).\n\n\n    this.onHorizontalViewportChanged(); // so when we return back to user, the cells have rendered\n\n    this.animationFrameService.flushAllFrames();\n  };\n\n  GridPanel.prototype.showLoadingOverlay = function () {\n    if (!this.gridOptionsWrapper.isSuppressLoadingOverlay()) {\n      this.overlayWrapper.showLoadingOverlay(this.eOverlay);\n    }\n  };\n\n  GridPanel.prototype.showNoRowsOverlay = function () {\n    if (!this.gridOptionsWrapper.isSuppressNoRowsOverlay()) {\n      this.overlayWrapper.showNoRowsOverlay(this.eOverlay);\n    }\n  };\n\n  GridPanel.prototype.hideOverlay = function () {\n    this.overlayWrapper.hideOverlay(this.eOverlay);\n  };\n\n  GridPanel.prototype.getWidthForSizeColsToFit = function () {\n    var availableWidth = this.eBody.clientWidth; // if pinning right, then the scroll bar can show, however for some reason\n    // it overlays the grid and doesn't take space. so we are only interested\n    // in the body scroll showing.\n\n    var removeVerticalScrollWidth = this.isVerticalScrollShowing();\n\n    if (removeVerticalScrollWidth) {\n      availableWidth -= this.scrollWidth;\n    }\n\n    return availableWidth;\n  }; // method will call itself if no available width. this covers if the grid\n  // isn't visible, but is just about to be visible.\n\n\n  GridPanel.prototype.sizeColumnsToFit = function (nextTimeout) {\n    var _this = this;\n\n    var availableWidth = this.getWidthForSizeColsToFit();\n\n    if (availableWidth > 0) {\n      this.columnController.sizeColumnsToFit(availableWidth, \"sizeColumnsToFit\");\n    } else {\n      if (nextTimeout === undefined) {\n        setTimeout(function () {\n          _this.sizeColumnsToFit(100);\n        }, 0);\n      } else if (nextTimeout === 100) {\n        setTimeout(function () {\n          _this.sizeColumnsToFit(500);\n        }, 100);\n      } else if (nextTimeout === 500) {\n        setTimeout(function () {\n          _this.sizeColumnsToFit(-1);\n        }, 500);\n      } else {\n        console.warn('ag-Grid: tried to call sizeColumnsToFit() but the grid is coming back with ' + 'zero width, maybe the grid is not visible yet on the screen?');\n      }\n    }\n  }; // used by autoWidthCalculator and autoHeightCalculator\n\n\n  GridPanel.prototype.getBodyContainer = function () {\n    return this.eBodyContainer;\n  };\n\n  GridPanel.prototype.getDropTargetBodyContainers = function () {\n    return [this.eBodyViewport, this.eTopViewport, this.eBottomViewport];\n  };\n\n  GridPanel.prototype.getDropTargetLeftContainers = function () {\n    return [this.eLeftViewport, this.eLeftBottom, this.eLeftTop];\n  };\n\n  GridPanel.prototype.getDropTargetRightContainers = function () {\n    return [this.eRightViewport, this.eRightBottom, this.eRightTop];\n  };\n\n  GridPanel.prototype.buildRowContainerComponents = function () {\n    var _this = this;\n\n    this.eAllCellContainers = [this.eLeftContainer, this.eRightContainer, this.eBodyContainer, this.eTop, this.eBottom, this.eFullWidthContainer];\n    this.rowContainerComponents = {\n      body: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eBodyContainer,\n        eViewport: this.eBodyViewport\n      }),\n      fullWidth: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eFullWidthContainer,\n        hideWhenNoChildren: true,\n        eViewport: this.eFullWidthViewport\n      }),\n      pinnedLeft: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eLeftContainer,\n        eViewport: this.eLeftViewport\n      }),\n      pinnedRight: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eRightContainer,\n        eViewport: this.eRightViewport\n      }),\n      floatingTop: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eTopContainer\n      }),\n      floatingTopPinnedLeft: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eLeftTop\n      }),\n      floatingTopPinnedRight: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eRightTop\n      }),\n      floatingTopFullWidth: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eTopFullWidthContainer,\n        hideWhenNoChildren: true\n      }),\n      floatingBottom: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eBottomContainer\n      }),\n      floatingBottomPinnedLeft: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eLeftBottom\n      }),\n      floatingBottomPinnedRight: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eRightBottom\n      }),\n      floatingBottomFullWith: new rowContainerComponent_1.RowContainerComponent({\n        eContainer: this.eBottomFullWidthContainer,\n        hideWhenNoChildren: true\n      })\n    };\n    utils_1.Utils.iterateObject(this.rowContainerComponents, function (key, container) {\n      if (container) {\n        _this.context.wireBean(container);\n      }\n    });\n  };\n\n  GridPanel.prototype.setupRowAnimationCssClass = function () {\n    var _this = this;\n\n    var listener = function listener() {\n      // we don't want to use row animation if scaling, as rows jump strangely as you scroll,\n      // when scaling and doing row animation.\n      var animateRows = _this.gridOptionsWrapper.isAnimateRows() && !_this.heightScaler.isScaling();\n      utils_1.Utils.addOrRemoveCssClass(_this.eBody, 'ag-row-animation', animateRows);\n      utils_1.Utils.addOrRemoveCssClass(_this.eBody, 'ag-row-no-animation', !animateRows);\n    };\n\n    listener();\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_HEIGHT_SCALE_CHANGED, listener);\n  }; // when editing a pinned row, if the cell is half outside the scrollable area, the browser can\n  // scroll the column into view. we do not want this, the pinned sections should never scroll.\n  // so we listen to scrolls on these containers and reset the scroll if we find one.\n\n\n  GridPanel.prototype.suppressScrollOnFloatingRow = function () {\n    var _this = this;\n\n    var resetTopScroll = function resetTopScroll() {\n      return _this.eTopViewport.scrollLeft = 0;\n    };\n\n    var resetBottomScroll = function resetBottomScroll() {\n      return _this.eTopViewport.scrollLeft = 0;\n    };\n\n    this.addDestroyableEventListener(this.eTopViewport, 'scroll', resetTopScroll);\n    this.addDestroyableEventListener(this.eBottomViewport, 'scroll', resetBottomScroll);\n  };\n\n  GridPanel.prototype.getRowContainers = function () {\n    return this.rowContainerComponents;\n  };\n\n  GridPanel.prototype.onDisplayedColumnsChanged = function () {\n    this.setPinnedContainersVisible();\n    this.setBodyAndHeaderHeights();\n    this.onHorizontalViewportChanged();\n  };\n\n  GridPanel.prototype.onDisplayedColumnsWidthChanged = function () {\n    this.setWidthsOfContainers();\n    this.onHorizontalViewportChanged();\n\n    if (this.enableRtl) {\n      // because RTL is all backwards, a change in the width of the row\n      // can cause a change in the scroll position, without a scroll event,\n      // because the scroll position in RTL is a function that depends on\n      // the width. to be convinced of this, take out this line, enable RTL,\n      // scroll all the way to the left and then resize a column\n      this.horizontallyScrollHeaderCenterAndFloatingCenter();\n    }\n  };\n\n  GridPanel.prototype.setWidthsOfContainers = function () {\n    this.setCenterWidth();\n    this.setPinnedLeftWidth();\n    this.setPinnedRightWidth();\n  };\n\n  GridPanel.prototype.setCenterWidth = function () {\n    var width = this.columnController.getBodyContainerWidth();\n\n    if (this.printLayout) {\n      var pinnedContainerWidths = this.columnController.getPinnedLeftContainerWidth() + this.columnController.getPinnedRightContainerWidth();\n      width += pinnedContainerWidths;\n    }\n\n    var widthPx = width + 'px';\n    this.eBodyContainer.style.width = widthPx;\n    this.eBottomContainer.style.width = widthPx;\n    this.eTopContainer.style.width = widthPx;\n  };\n\n  GridPanel.prototype.setPinnedLeftWidth = function () {\n    var widthOfCols = this.columnController.getPinnedLeftContainerWidth();\n    var showContainers = !this.printLayout && widthOfCols > 0;\n    var eParentContainers = [this.eLeftViewportWrapper, this.eLeftTop, this.eLeftBottom];\n    eParentContainers.forEach(function (e) {\n      return utils_1.Utils.setVisible(e, showContainers);\n    });\n\n    if (!showContainers) {\n      return;\n    }\n\n    var viewportWidth;\n    var wrapperWidth;\n\n    if (utils_1.Utils.isVerticalScrollShowing(this.eLeftViewport)) {\n      if (this.enableRtl) {\n        // show the scroll\n        viewportWidth = '100%';\n        wrapperWidth = widthOfCols + this.scrollWidth;\n      } else {\n        // hide the scroll, this makes the wrapper clip the scroll\n        viewportWidth = \"calc(100% + \" + this.scrollClipWidth + \"px)\";\n        wrapperWidth = widthOfCols;\n      }\n    } else {\n      // no scroll\n      viewportWidth = '100%';\n      wrapperWidth = widthOfCols;\n    }\n\n    this.eLeftViewport.style.width = viewportWidth;\n    this.eLeftViewportWrapper.style.maxWidth = wrapperWidth + 'px'; // .width didn't do the trick in firefox, so needed .minWidth also\n\n    this.eLeftContainer.style.width = widthOfCols + 'px';\n    this.eLeftContainer.style.minWidth = widthOfCols + 'px';\n    this.eLeftBottom.style.maxWidth = wrapperWidth + 'px';\n    this.eLeftTop.style.maxWidth = wrapperWidth + 'px';\n  };\n\n  GridPanel.prototype.setPinnedRightWidth = function () {\n    var widthOfCols = this.columnController.getPinnedRightContainerWidth();\n    var visible = !this.printLayout && widthOfCols > 0;\n    var eParentContainers = [this.eRightViewportWrapper, this.eRightTop, this.eRightBottom];\n    eParentContainers.forEach(function (e) {\n      return utils_1.Utils.setVisible(e, visible);\n    });\n\n    if (!visible) {\n      return;\n    }\n\n    var viewportWidth;\n    var wrapperWidth;\n\n    if (utils_1.Utils.isVerticalScrollShowing(this.eRightViewport)) {\n      if (!this.enableRtl) {\n        // show the scroll\n        viewportWidth = '100%';\n        wrapperWidth = widthOfCols + this.scrollWidth;\n      } else {\n        // hide the scroll, this makes the wrapper clip the scroll\n        viewportWidth = \"calc(100% + \" + this.scrollClipWidth + \"px)\";\n        wrapperWidth = widthOfCols;\n      }\n    } else {\n      // no scroll\n      viewportWidth = \"100%\";\n      wrapperWidth = widthOfCols;\n    }\n\n    this.eRightViewport.style.width = viewportWidth;\n    this.eRightViewportWrapper.style.maxWidth = wrapperWidth + 'px'; // .width didn't do the trick in firefox, so needed .minWidth also\n\n    this.eRightContainer.style.width = widthOfCols + 'px';\n    this.eRightContainer.style.minWidth = widthOfCols + 'px';\n    this.eRightTop.style.maxWidth = wrapperWidth + 'px';\n    this.eRightBottom.style.maxWidth = wrapperWidth + 'px';\n  };\n\n  GridPanel.prototype.setPinnedContainersVisible = function () {\n    var changeDetected = false;\n    var showLeftPinned = this.printLayout ? false : this.columnController.isPinningLeft();\n\n    if (showLeftPinned !== this.pinningLeft) {\n      this.pinningLeft = showLeftPinned;\n      this.headerRootComp.setLeftVisible(showLeftPinned);\n      utils_1.Utils.setVisible(this.eLeftViewportWrapper, showLeftPinned);\n      changeDetected = true;\n\n      if (showLeftPinned) {\n        // because the viewport was not visible, it was not keeping previous scrollTop values\n        this.eLeftViewport.scrollTop = this.eBodyViewport.scrollTop;\n      }\n    }\n\n    var showRightPinned = this.printLayout ? false : this.columnController.isPinningRight();\n\n    if (showRightPinned !== this.pinningRight) {\n      this.pinningRight = showRightPinned;\n      this.headerRootComp.setRightVisible(showRightPinned);\n      utils_1.Utils.setVisible(this.eRightViewportWrapper, showRightPinned);\n\n      if (showRightPinned) {\n        // because the viewport was not visible, it was not keeping previous scrollTop values\n        this.eRightViewport.scrollTop = this.eBodyViewport.scrollTop;\n      }\n\n      changeDetected = true;\n    }\n\n    if (changeDetected) {\n      this.hideVerticalScrollOnCenter();\n      this.setPinnedLeftWidth();\n      this.setPinnedRightWidth();\n    }\n  };\n\n  GridPanel.prototype.hideVerticalScrollOnCenter = function () {\n    var neverShowScroll = this.enableRtl ? this.columnController.isPinningLeft() : this.columnController.isPinningRight();\n    var scrollActive = !this.printLayout && utils_1.Utils.isVerticalScrollShowing(this.eBodyViewport);\n    var hideScroll = neverShowScroll && scrollActive;\n    var margin = hideScroll ? '-' + this.scrollClipWidth + 'px' : '';\n\n    if (this.enableRtl) {\n      this.eBodyViewport.style.marginLeft = margin;\n    } else {\n      this.eBodyViewport.style.marginRight = margin;\n    }\n  };\n\n  GridPanel.prototype.checkBodyHeight = function () {\n    var bodyHeight = this.eBody.clientHeight;\n\n    if (this.bodyHeight !== bodyHeight) {\n      this.bodyHeight = bodyHeight;\n      var event_3 = {\n        type: events_1.Events.EVENT_BODY_HEIGHT_CHANGED,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_3);\n    }\n  };\n\n  GridPanel.prototype.setBodyAndHeaderHeights = function () {\n    var headerRowCount = this.columnController.getHeaderRowCount();\n    var totalHeaderHeight;\n    var numberOfFloating = 0;\n    var groupHeight;\n    var headerHeight;\n\n    if (!this.columnController.isPivotMode()) {\n      if (this.gridOptionsWrapper.isFloatingFilter()) {\n        headerRowCount++;\n      }\n\n      numberOfFloating = this.gridOptionsWrapper.isFloatingFilter() ? 1 : 0;\n      groupHeight = this.gridOptionsWrapper.getGroupHeaderHeight();\n      headerHeight = this.gridOptionsWrapper.getHeaderHeight();\n    } else {\n      numberOfFloating = 0;\n      groupHeight = this.gridOptionsWrapper.getPivotGroupHeaderHeight();\n      headerHeight = this.gridOptionsWrapper.getPivotHeaderHeight();\n    }\n\n    var numberOfNonGroups = 1 + numberOfFloating;\n    var numberOfGroups = headerRowCount - numberOfNonGroups;\n    totalHeaderHeight = numberOfFloating * this.gridOptionsWrapper.getFloatingFiltersHeight();\n    totalHeaderHeight += numberOfGroups * groupHeight;\n    totalHeaderHeight += headerHeight;\n    this.headerRootComp.setHeight(totalHeaderHeight);\n    var floatingTopHeight = this.pinnedRowModel.getPinnedTopTotalHeight();\n    var floatingBottomHeight = this.pinnedRowModel.getPinnedBottomTotalHeight();\n    this.eTop.style.minHeight = floatingTopHeight + 'px';\n    this.eTop.style.height = floatingTopHeight + 'px';\n    this.eBottom.style.minHeight = floatingBottomHeight + 'px';\n    this.eBottom.style.height = floatingBottomHeight + 'px';\n    this.checkBodyHeight();\n  };\n\n  GridPanel.prototype.getBodyHeight = function () {\n    return this.bodyHeight;\n  };\n\n  GridPanel.prototype.setHorizontalScrollPosition = function (hScrollPosition) {\n    this.eBodyViewport.scrollLeft = hScrollPosition; // we need to manually do the event handling (rather than wait for the event)\n    // for the alignedGridsService, as if we don't, the aligned grid service gets\n    // notified async, and then it's 'consuming' flag doesn't get used right, and\n    // we can end up with an infinite loop\n\n    if (this.nextScrollLeft !== hScrollPosition) {\n      this.nextScrollLeft = hScrollPosition;\n      this.doHorizontalScroll();\n    }\n  };\n\n  GridPanel.prototype.setVerticalScrollPosition = function (vScrollPosition) {\n    this.eBodyViewport.scrollTop = vScrollPosition;\n  }; // tries to scroll by pixels, but returns what the result actually was\n\n\n  GridPanel.prototype.scrollHorizontally = function (pixels) {\n    var oldScrollPosition = this.eBodyViewport.scrollLeft;\n    this.setHorizontalScrollPosition(oldScrollPosition + pixels);\n    var newScrollPosition = this.eBodyViewport.scrollLeft;\n    return newScrollPosition - oldScrollPosition;\n  }; // tries to scroll by pixels, but returns what the result actually was\n\n\n  GridPanel.prototype.scrollVertically = function (pixels) {\n    var oldScrollPosition = this.eBodyViewport.scrollTop;\n    this.setVerticalScrollPosition(oldScrollPosition + pixels);\n    var newScrollPosition = this.eBodyViewport.scrollTop;\n    return newScrollPosition - oldScrollPosition;\n  };\n\n  GridPanel.prototype.addScrollListener = function () {\n    var _this = this;\n\n    this.addDestroyableEventListener(this.eBodyViewport, 'scroll', function (e) {\n      _this.onBodyHorizontalScroll();\n\n      _this.onAnyBodyScroll(_this.eBodyViewport);\n    });\n    this.addDestroyableEventListener(this.eRightViewport, 'scroll', this.onAnyBodyScroll.bind(this, this.eRightViewport));\n    this.addDestroyableEventListener(this.eLeftViewport, 'scroll', this.onAnyBodyScroll.bind(this, this.eLeftViewport));\n    this.addDestroyableEventListener(this.eFullWidthViewport, 'scroll', this.onAnyBodyScroll.bind(this, this.eFullWidthViewport));\n  };\n\n  GridPanel.prototype.eventDueToMakingContainerVisible = function (source) {\n    if (source.scrollTop !== 0) {\n      return false;\n    }\n\n    switch (source) {\n      case this.eBodyViewport:\n        return this.rowContainerComponents.body.isMadeVisibleRecently();\n\n      case this.eLeftViewport:\n        return this.rowContainerComponents.pinnedLeft.isMadeVisibleRecently();\n\n      case this.eRightViewport:\n        return this.rowContainerComponents.pinnedRight.isMadeVisibleRecently();\n\n      case this.eFullWidthViewport:\n        return this.rowContainerComponents.fullWidth.isMadeVisibleRecently();\n\n      default:\n        return false;\n    }\n  };\n\n  GridPanel.prototype.onAnyBodyScroll = function (source) {\n    var now = new Date().getTime(); // when a row container becomes visible, it fires and event to say 'scroll at zero' which we don't want.\n    // this caused a problem in particular with SSRM where the loading stub cell was using full width (and\n    // hence the fullWidth row container was visible) and then when loading was done, the full width row\n    // goes, and then left with no full with rows so the full with row container is made not visible.\n    // the showing / hiding of the full width container was causing scroll events to zero scroll position\n    // to be fired. if we act on these events, it would result in the scroll resetting back to the top.\n    // we avoid this be skipping these events. this problem only appears to happen with Chrome.\n\n    if (this.eventDueToMakingContainerVisible(source)) {\n      return;\n    } // recentScrolls: when one scrollable area is scrolling (eg center) then the\n    // other scroll areas are also scrolled (eg pinned left, pinned right, full width).\n    // we want to ignore events that are as a result of the other panels scrolling,\n    // eg if body scrolls to 100px, then we want to ignore the events coming from\n    // the other panels for 100px. if we don't do this, then we will end up with events\n    // interfering wih the scroll when there is a stream of events. this was most notable\n    // on IE, but impacted all browsers to some extent.\n\n\n    var lastTimeScrolledToHere = this.recentScrolls[source.scrollTop];\n    var scrolledToHereRecently = lastTimeScrolledToHere && now - lastTimeScrolledToHere < 250;\n\n    if (scrolledToHereRecently) {\n      return;\n    }\n\n    this.recentScrolls[source.scrollTop] = now;\n    this.lastVScrollElement = source;\n    var scrollTop = source.scrollTop;\n\n    if (this.useAnimationFrame) {\n      if (this.nextScrollTop !== scrollTop) {\n        this.nextScrollTop = scrollTop;\n        this.animationFrameService.schedule();\n      }\n    } else {\n      if (scrollTop !== this.scrollTop) {\n        this.scrollTop = scrollTop;\n        this.synchroniseVerticalScrollPositions(scrollTop);\n        this.redrawRowsAfterScroll();\n      }\n    }\n  };\n\n  GridPanel.prototype.onBodyHorizontalScroll = function () {\n    var supportsOverflowScrolling = this.animationFrameService.isSupportsOverflowScrolling();\n    var _a = this.eBodyViewport,\n        scrollWidth = _a.scrollWidth,\n        clientWidth = _a.clientWidth; // in chrome, fractions can be in the scroll left, eg 250.342234 - which messes up our 'scrollWentPastBounds'\n    // formula. so we floor it to allow the formula to work.\n\n    var scrollLeft = Math.floor(utils_1.Utils.getScrollLeft(this.eBodyViewport, this.enableRtl)); // touch devices allow elastic scroll - which temporally scrolls the panel outside of the viewport\n    // (eg user uses touch to go to the left of the grid, but drags past the left, the rows will actually\n    // scroll past the left until the user releases the mouse). when this happens, we want ignore the scroll,\n    // as otherwise it was causing the rows and header to flicker.\n\n    var scrollWentPastBounds = scrollLeft < 0 || scrollLeft + clientWidth > scrollWidth;\n\n    if (scrollWentPastBounds) {\n      return;\n    }\n\n    if (this.nextScrollLeft !== scrollLeft) {\n      this.nextScrollLeft = scrollLeft; // for touch devices, we found scrolling was jerky when combining overflow scrolling and ag-grid\n      // animation frames. so if overflow scroll is supported (which means user is typically on a tab or phone)\n      // we don't use the animation frame service for horizontal scrolling.\n\n      if (!this.useAnimationFrame || supportsOverflowScrolling) {\n        this.doHorizontalScroll();\n      } else {\n        this.animationFrameService.schedule();\n      }\n    }\n  };\n\n  GridPanel.prototype.doHorizontalScroll = function () {\n    this.scrollLeft = this.nextScrollLeft;\n    var event = {\n      type: events_1.Events.EVENT_BODY_SCROLL,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      direction: 'horizontal',\n      left: this.scrollLeft,\n      top: this.scrollTop\n    };\n    this.eventService.dispatchEvent(event);\n    this.horizontallyScrollHeaderCenterAndFloatingCenter();\n    this.onHorizontalViewportChanged();\n  };\n\n  GridPanel.prototype.executeFrame = function () {\n    if (this.scrollLeft !== this.nextScrollLeft) {\n      this.doHorizontalScroll();\n      return true;\n    } else if (this.scrollTop !== this.nextScrollTop) {\n      this.scrollTop = this.nextScrollTop;\n      this.synchroniseVerticalScrollPositions(this.scrollTop);\n      this.verticalRedrawNeeded = true;\n      return true;\n    } else if (this.verticalRedrawNeeded) {\n      this.redrawRowsAfterScroll();\n      this.verticalRedrawNeeded = false;\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  GridPanel.prototype.redrawRowsAfterScroll = function () {\n    var event = {\n      type: events_1.Events.EVENT_BODY_SCROLL,\n      direction: 'vertical',\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      left: this.scrollLeft,\n      top: this.scrollTop\n    };\n    this.eventService.dispatchEvent(event);\n  }; // this gets called whenever a change in the viewport, so we can inform column controller it has to work\n  // out the virtual columns again. gets called from following locations:\n  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged, API (doLayout)\n\n\n  GridPanel.prototype.onHorizontalViewportChanged = function () {\n    var scrollWidth = this.eBodyViewport.clientWidth;\n    var scrollPosition = this.getBodyViewportScrollLeft();\n    this.columnController.setVirtualViewportPosition(scrollWidth, scrollPosition);\n  };\n\n  GridPanel.prototype.getBodyViewportScrollLeft = function () {\n    // we defer to a util, as how you calculated scrollLeft when doing RTL depends on the browser\n    return utils_1.Utils.getScrollLeft(this.eBodyViewport, this.enableRtl);\n  };\n\n  GridPanel.prototype.setBodyViewportScrollLeft = function (value) {\n    // we defer to a util, as how you calculated scrollLeft when doing RTL depends on the browser\n    utils_1.Utils.setScrollLeft(this.eBodyViewport, value, this.enableRtl);\n  };\n\n  GridPanel.prototype.horizontallyScrollHeaderCenterAndFloatingCenter = function () {\n    var scrollLeft = this.getBodyViewportScrollLeft();\n    var offset = this.enableRtl ? scrollLeft : -scrollLeft;\n    this.headerRootComp.setHorizontalScroll(offset);\n    this.eBottomContainer.style.left = offset + 'px';\n    this.eTopContainer.style.left = offset + 'px';\n  };\n\n  GridPanel.prototype.synchroniseVerticalScrollPositions = function (position) {\n    if (this.lastVScrollElement !== this.eBodyViewport) {\n      this.eBodyViewport.scrollTop = position;\n    }\n\n    if (this.lastVScrollElement !== this.eLeftViewport && this.pinningLeft) {\n      this.eLeftViewport.scrollTop = position;\n    }\n\n    if (this.lastVScrollElement !== this.eRightViewport && this.pinningRight) {\n      this.eRightViewport.scrollTop = position;\n    }\n\n    if (this.lastVScrollElement !== this.eFullWidthViewport) {\n      this.eFullWidthViewport.scrollTop = position;\n    } // the row containers need to remember the scroll position, as if they are made\n    // hidden / shown, the scroll position is lost\n\n\n    this.rowContainerComponents.body.setVerticalScrollPosition(position);\n    this.rowContainerComponents.pinnedLeft.setVerticalScrollPosition(position);\n    this.rowContainerComponents.pinnedRight.setVerticalScrollPosition(position);\n    this.rowContainerComponents.fullWidth.setVerticalScrollPosition(position);\n    this.redrawRowsAfterScroll();\n  };\n\n  GridPanel.prototype.addScrollEventListener = function (listener) {\n    this.eBodyViewport.addEventListener('scroll', listener);\n  };\n\n  GridPanel.prototype.removeScrollEventListener = function (listener) {\n    this.eBodyViewport.removeEventListener('scroll', listener);\n  };\n\n  __decorate([context_1.Autowired('alignedGridsService'), __metadata(\"design:type\", alignedGridsService_1.AlignedGridsService)], GridPanel.prototype, \"alignedGridsService\", void 0);\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], GridPanel.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.Autowired('columnController'), __metadata(\"design:type\", columnController_1.ColumnController)], GridPanel.prototype, \"columnController\", void 0);\n\n  __decorate([context_1.Autowired('rowRenderer'), __metadata(\"design:type\", rowRenderer_1.RowRenderer)], GridPanel.prototype, \"rowRenderer\", void 0);\n\n  __decorate([context_1.Autowired('pinnedRowModel'), __metadata(\"design:type\", pinnedRowModel_1.PinnedRowModel)], GridPanel.prototype, \"pinnedRowModel\", void 0);\n\n  __decorate([context_1.Autowired('eventService'), __metadata(\"design:type\", eventService_1.EventService)], GridPanel.prototype, \"eventService\", void 0);\n\n  __decorate([context_1.Autowired('context'), __metadata(\"design:type\", context_1.Context)], GridPanel.prototype, \"context\", void 0);\n\n  __decorate([context_1.Autowired('animationFrameService'), __metadata(\"design:type\", animationFrameService_1.AnimationFrameService)], GridPanel.prototype, \"animationFrameService\", void 0);\n\n  __decorate([context_1.Autowired('navigationService'), __metadata(\"design:type\", navigationService_1.NavigationService)], GridPanel.prototype, \"navigationService\", void 0);\n\n  __decorate([context_1.Autowired('autoHeightCalculator'), __metadata(\"design:type\", autoHeightCalculator_1.AutoHeightCalculator)], GridPanel.prototype, \"autoHeightCalculator\", void 0);\n\n  __decorate([context_1.Autowired('columnAnimationService'), __metadata(\"design:type\", columnAnimationService_1.ColumnAnimationService)], GridPanel.prototype, \"columnAnimationService\", void 0);\n\n  __decorate([context_1.Autowired('autoWidthCalculator'), __metadata(\"design:type\", autoWidthCalculator_1.AutoWidthCalculator)], GridPanel.prototype, \"autoWidthCalculator\", void 0);\n\n  __decorate([context_1.Autowired('paginationAutoPageSizeService'), __metadata(\"design:type\", paginationProxy_1.PaginationAutoPageSizeService)], GridPanel.prototype, \"paginationAutoPageSizeService\", void 0);\n\n  __decorate([context_1.Autowired('beans'), __metadata(\"design:type\", beans_1.Beans)], GridPanel.prototype, \"beans\", void 0);\n\n  __decorate([context_1.Autowired('paginationProxy'), __metadata(\"design:type\", paginationProxy_1.PaginationProxy)], GridPanel.prototype, \"paginationProxy\", void 0);\n\n  __decorate([context_1.Autowired('columnApi'), __metadata(\"design:type\", columnApi_1.ColumnApi)], GridPanel.prototype, \"columnApi\", void 0);\n\n  __decorate([context_1.Autowired('gridApi'), __metadata(\"design:type\", gridApi_1.GridApi)], GridPanel.prototype, \"gridApi\", void 0);\n\n  __decorate([context_1.Autowired('dragService'), __metadata(\"design:type\", dragService_1.DragService)], GridPanel.prototype, \"dragService\", void 0);\n\n  __decorate([context_1.Autowired('selectionController'), __metadata(\"design:type\", selectionController_1.SelectionController)], GridPanel.prototype, \"selectionController\", void 0);\n\n  __decorate([context_1.Autowired('csvCreator'), __metadata(\"design:type\", csvCreator_1.CsvCreator)], GridPanel.prototype, \"csvCreator\", void 0);\n\n  __decorate([context_1.Autowired('mouseEventService'), __metadata(\"design:type\", mouseEventService_1.MouseEventService)], GridPanel.prototype, \"mouseEventService\", void 0);\n\n  __decorate([context_1.Autowired('focusedCellController'), __metadata(\"design:type\", focusedCellController_1.FocusedCellController)], GridPanel.prototype, \"focusedCellController\", void 0);\n\n  __decorate([context_1.Autowired('$scope'), __metadata(\"design:type\", Object)], GridPanel.prototype, \"$scope\", void 0);\n\n  __decorate([context_1.Autowired('scrollVisibleService'), __metadata(\"design:type\", scrollVisibleService_1.ScrollVisibleService)], GridPanel.prototype, \"scrollVisibleService\", void 0);\n\n  __decorate([context_1.Autowired('frameworkFactory'), __metadata(\"design:type\", Object)], GridPanel.prototype, \"frameworkFactory\", void 0);\n\n  __decorate([context_1.Autowired('valueService'), __metadata(\"design:type\", valueService_1.ValueService)], GridPanel.prototype, \"valueService\", void 0);\n\n  __decorate([context_1.Autowired('componentRecipes'), __metadata(\"design:type\", componentRecipes_1.ComponentRecipes)], GridPanel.prototype, \"componentRecipes\", void 0);\n\n  __decorate([context_1.Autowired('dragAndDropService'), __metadata(\"design:type\", dragAndDropService_1.DragAndDropService)], GridPanel.prototype, \"dragAndDropService\", void 0);\n\n  __decorate([context_1.Autowired('heightScaler'), __metadata(\"design:type\", heightScaler_1.HeightScaler)], GridPanel.prototype, \"heightScaler\", void 0);\n\n  __decorate([context_1.Autowired('enterprise'), __metadata(\"design:type\", Boolean)], GridPanel.prototype, \"enterprise\", void 0);\n\n  __decorate([context_1.Autowired('resizeObserverService'), __metadata(\"design:type\", resizeObserverService_1.ResizeObserverService)], GridPanel.prototype, \"resizeObserverService\", void 0);\n\n  __decorate([context_1.Optional('rangeController'), __metadata(\"design:type\", Object)], GridPanel.prototype, \"rangeController\", void 0);\n\n  __decorate([context_1.Optional('contextMenuFactory'), __metadata(\"design:type\", Object)], GridPanel.prototype, \"contextMenuFactory\", void 0);\n\n  __decorate([context_1.Optional('clipboardService'), __metadata(\"design:type\", Object)], GridPanel.prototype, \"clipboardService\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eBody'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eBody\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eBodyViewport'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eBodyViewport\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eBodyContainer'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eBodyContainer\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eBodyViewportWrapper'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eBodyViewportWrapper\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eLeftContainer'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eLeftContainer\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eRightContainer'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eRightContainer\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eFullWidthViewportWrapper'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eFullWidthViewportWrapper\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eFullWidthViewport'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eFullWidthViewport\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eFullWidthContainer'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eFullWidthContainer\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eLeftViewport'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eLeftViewport\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eLeftViewportWrapper'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eLeftViewportWrapper\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eRightViewport'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eRightViewport\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eRightViewportWrapper'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eRightViewportWrapper\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eTop'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eTop\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eLeftTop'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eLeftTop\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eRightTop'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eRightTop\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eTopContainer'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eTopContainer\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eTopViewport'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eTopViewport\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eTopFullWidthContainer'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eTopFullWidthContainer\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eBottom'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eBottom\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eLeftBottom'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eLeftBottom\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eRightBottom'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eRightBottom\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eBottomContainer'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eBottomContainer\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eBottomViewport'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eBottomViewport\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('eBottomFullWidthContainer'), __metadata(\"design:type\", HTMLElement)], GridPanel.prototype, \"eBottomFullWidthContainer\", void 0);\n\n  __decorate([componentAnnotations_1.RefSelector('headerRoot'), __metadata(\"design:type\", headerRootComp_1.HeaderRootComp)], GridPanel.prototype, \"headerRootComp\", void 0);\n\n  __decorate([context_1.PreDestroy, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], GridPanel.prototype, \"destroy\", null);\n\n  __decorate([context_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], GridPanel.prototype, \"init\", null);\n\n  return GridPanel;\n}(component_1.Component);\n\nexports.GridPanel = GridPanel;","map":null,"metadata":{},"sourceType":"script"}