{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar context_1 = require(\"../../context/context\");\n\nvar rowNode_1 = require(\"../../entities/rowNode\");\n\nvar utils_1 = require(\"../../utils\");\n\nvar gridOptionsWrapper_1 = require(\"../../gridOptionsWrapper\");\n\nvar selectionController_1 = require(\"../../selectionController\");\n\nvar eventService_1 = require(\"../../eventService\");\n\nvar columnController_1 = require(\"../../columnController/columnController\");\n\nvar FlattenStage =\n/** @class */\nfunction () {\n  function FlattenStage() {}\n\n  FlattenStage.prototype.execute = function (params) {\n    var rootNode = params.rowNode; // even if not doing grouping, we do the mapping, as the client might\n    // of passed in data that already has a grouping in it somewhere\n\n    var result = []; // putting value into a wrapper so it's passed by reference\n\n    var nextRowTop = {\n      value: 0\n    };\n    var skipLeafNodes = this.columnController.isPivotMode(); // if we are reducing, and not grouping, then we want to show the root node, as that\n    // is where the pivot values are\n\n    var showRootNode = skipLeafNodes && rootNode.leafGroup;\n    var topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort; // set all row tops to null, then set row tops on all visible rows. if we don't\n    // do this, then the algorithm below only sets row tops, old row tops from old rows\n    // will still lie around\n\n    this.resetRowTops(rootNode);\n    this.recursivelyAddToRowsToDisplay(topList, result, nextRowTop, skipLeafNodes, 0); // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)\n\n    var includeGroupTotalFooter = !showRootNode && this.gridOptionsWrapper.isGroupIncludeTotalFooter();\n\n    if (includeGroupTotalFooter) {\n      this.ensureFooterNodeExists(rootNode);\n      this.addRowNodeToRowsToDisplay(rootNode.sibling, result, nextRowTop, 0);\n    }\n\n    return result;\n  };\n\n  FlattenStage.prototype.resetRowTops = function (rowNode) {\n    rowNode.clearRowTop();\n\n    if (rowNode.hasChildren()) {\n      if (rowNode.childrenAfterGroup) {\n        for (var i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n          this.resetRowTops(rowNode.childrenAfterGroup[i]);\n        }\n      }\n\n      if (rowNode.sibling) {\n        rowNode.sibling.clearRowTop();\n      }\n    }\n\n    if (rowNode.detailNode) {\n      rowNode.detailNode.clearRowTop();\n    }\n  };\n\n  FlattenStage.prototype.recursivelyAddToRowsToDisplay = function (rowsToFlatten, result, nextRowTop, skipLeafNodes, uiLevel) {\n    if (utils_1.Utils.missingOrEmpty(rowsToFlatten)) {\n      return;\n    }\n\n    var groupSuppressRow = this.gridOptionsWrapper.isGroupSuppressRow();\n    var hideOpenParents = this.gridOptionsWrapper.isGroupHideOpenParents(); // these two are mutually exclusive, so if first set, we don't set the second\n\n    var groupRemoveSingleChildren = this.gridOptionsWrapper.isGroupRemoveSingleChildren();\n    var groupRemoveLowestSingleChildren = !groupRemoveSingleChildren && this.gridOptionsWrapper.isGroupRemoveLowestSingleChildren();\n\n    for (var i = 0; i < rowsToFlatten.length; i++) {\n      var rowNode = rowsToFlatten[i]; // check all these cases, for working out if this row should be included in the final mapped list\n\n      var isParent = rowNode.hasChildren();\n      var isGroupSuppressedNode = groupSuppressRow && isParent;\n      var isSkippedLeafNode = skipLeafNodes && !isParent;\n      var isRemovedSingleChildrenGroup = groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup.length === 1;\n      var isRemovedLowestSingleChildrenGroup = groupRemoveLowestSingleChildren && isParent && rowNode.leafGroup && rowNode.childrenAfterGroup.length === 1; // hide open parents means when group is open, we don't show it. we also need to make sure the\n      // group is expandable in the first place (as leaf groups are not expandable if pivot mode is on).\n      // the UI will never allow expanding leaf  groups, however the user might via the API (or menu option 'expand all')\n\n      var neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;\n      var isHiddenOpenParent = hideOpenParents && rowNode.expanded && !neverAllowToExpand;\n      var thisRowShouldBeRendered = !isSkippedLeafNode && !isGroupSuppressedNode && !isHiddenOpenParent && !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;\n\n      if (thisRowShouldBeRendered) {\n        this.addRowNodeToRowsToDisplay(rowNode, result, nextRowTop, uiLevel);\n      } // if we are pivoting, we never map below the leaf group\n\n\n      if (skipLeafNodes && rowNode.leafGroup) {\n        continue;\n      }\n\n      if (isParent) {\n        var excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup; // we traverse the group if it is expended, however we always traverse if the parent node\n        // was removed (as the group will never be opened if it is not displayed, we show the children instead)\n\n        if (rowNode.expanded || excludedParent) {\n          // if the parent was excluded, then ui level is that of the parent\n          var uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;\n          this.recursivelyAddToRowsToDisplay(rowNode.childrenAfterSort, result, nextRowTop, skipLeafNodes, uiLevelForChildren); // put a footer in if user is looking for it\n\n          if (this.gridOptionsWrapper.isGroupIncludeFooter()) {\n            this.ensureFooterNodeExists(rowNode);\n            this.addRowNodeToRowsToDisplay(rowNode.sibling, result, nextRowTop, uiLevel);\n          }\n        } else {}\n      } else if (rowNode.master && rowNode.expanded) {\n        var detailNode = this.createDetailNode(rowNode);\n        this.addRowNodeToRowsToDisplay(detailNode, result, nextRowTop, uiLevel);\n      }\n    }\n  }; // duplicated method, it's also in floatingRowModel\n\n\n  FlattenStage.prototype.addRowNodeToRowsToDisplay = function (rowNode, result, nextRowTop, uiLevel) {\n    result.push(rowNode);\n\n    if (utils_1.Utils.missing(rowNode.rowHeight)) {\n      var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);\n      rowNode.setRowHeight(rowHeight);\n    }\n\n    rowNode.setUiLevel(uiLevel);\n    rowNode.setRowTop(nextRowTop.value);\n    rowNode.setRowIndex(result.length - 1);\n    nextRowTop.value += rowNode.rowHeight;\n  };\n\n  FlattenStage.prototype.ensureFooterNodeExists = function (groupNode) {\n    // only create footer node once, otherwise we have daemons and\n    // the animate screws up with the daemons hanging around\n    if (utils_1.Utils.exists(groupNode.sibling)) {\n      return;\n    }\n\n    var footerNode = new rowNode_1.RowNode();\n    this.context.wireBean(footerNode);\n    Object.keys(groupNode).forEach(function (key) {\n      footerNode[key] = groupNode[key];\n    });\n    footerNode.footer = true;\n    footerNode.rowTop = null;\n    footerNode.oldRowTop = null;\n\n    if (utils_1.Utils.exists(footerNode.id)) {\n      footerNode.id = 'rowGroupFooter_' + footerNode.id;\n    } // get both header and footer to reference each other as siblings. this is never undone,\n    // only overwritten. so if a group is expanded, then contracted, it will have a ghost\n    // sibling - but that's fine, as we can ignore this if the header is contracted.\n\n\n    footerNode.sibling = groupNode;\n    groupNode.sibling = footerNode;\n  };\n\n  FlattenStage.prototype.createDetailNode = function (masterNode) {\n    if (utils_1.Utils.exists(masterNode.detailNode)) {\n      return masterNode.detailNode;\n    } else {\n      var detailNode = new rowNode_1.RowNode();\n      this.context.wireBean(detailNode);\n      detailNode.detail = true;\n      detailNode.selectable = false; // flower was renamed to 'detail', but keeping for backwards compatibility\n\n      detailNode.flower = detailNode.detail;\n      detailNode.parent = masterNode;\n\n      if (utils_1.Utils.exists(masterNode.id)) {\n        detailNode.id = 'detail_' + masterNode.id;\n      }\n\n      detailNode.data = masterNode.data;\n      detailNode.level = masterNode.level + 1;\n      masterNode.detailNode = detailNode;\n      masterNode.childFlower = masterNode.detailNode; // for backwards compatibility\n\n      return detailNode;\n    }\n  };\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], FlattenStage.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.Autowired('selectionController'), __metadata(\"design:type\", selectionController_1.SelectionController)], FlattenStage.prototype, \"selectionController\", void 0);\n\n  __decorate([context_1.Autowired('eventService'), __metadata(\"design:type\", eventService_1.EventService)], FlattenStage.prototype, \"eventService\", void 0);\n\n  __decorate([context_1.Autowired('context'), __metadata(\"design:type\", context_1.Context)], FlattenStage.prototype, \"context\", void 0);\n\n  __decorate([context_1.Autowired('columnController'), __metadata(\"design:type\", columnController_1.ColumnController)], FlattenStage.prototype, \"columnController\", void 0);\n\n  FlattenStage = __decorate([context_1.Bean('flattenStage')], FlattenStage);\n  return FlattenStage;\n}();\n\nexports.FlattenStage = FlattenStage;","map":null,"metadata":{},"sourceType":"script"}