{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"../../utils\");\n\nvar gridOptionsWrapper_1 = require(\"../../gridOptionsWrapper\");\n\nvar context_1 = require(\"../../context/context\");\n\nvar eventService_1 = require(\"../../eventService\");\n\nvar selectionController_1 = require(\"../../selectionController\");\n\nvar events_1 = require(\"../../events\");\n\nvar sortController_1 = require(\"../../sortController\");\n\nvar filterManager_1 = require(\"../../filter/filterManager\");\n\nvar constants_1 = require(\"../../constants\");\n\nvar infiniteCache_1 = require(\"./infiniteCache\");\n\nvar beanStub_1 = require(\"../../context/beanStub\");\n\nvar rowNodeCache_1 = require(\"../cache/rowNodeCache\");\n\nvar rowNodeBlockLoader_1 = require(\"../cache/rowNodeBlockLoader\");\n\nvar gridApi_1 = require(\"../../gridApi\");\n\nvar columnApi_1 = require(\"../../columnController/columnApi\");\n\nvar InfiniteRowModel =\n/** @class */\nfunction (_super) {\n  __extends(InfiniteRowModel, _super);\n\n  function InfiniteRowModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  InfiniteRowModel.prototype.getRowBounds = function (index) {\n    return {\n      rowHeight: this.rowHeight,\n      rowTop: this.rowHeight * index\n    };\n  };\n\n  InfiniteRowModel.prototype.init = function () {\n    var _this = this;\n\n    if (!this.gridOptionsWrapper.isRowModelInfinite()) {\n      return;\n    }\n\n    this.rowHeight = this.gridOptionsWrapper.getRowHeightAsNumber();\n    this.addEventListeners();\n    this.setDatasource(this.gridOptionsWrapper.getDatasource());\n    this.addDestroyFunc(function () {\n      return _this.destroyCache();\n    });\n  };\n\n  InfiniteRowModel.prototype.destroyDatasource = function () {\n    if (this.datasource && this.datasource.destroy) {\n      this.datasource.destroy();\n    }\n\n    this.datasource = null;\n  };\n\n  InfiniteRowModel.prototype.isLastRowFound = function () {\n    return this.infiniteCache ? this.infiniteCache.isMaxRowFound() : false;\n  };\n\n  InfiniteRowModel.prototype.addEventListeners = function () {\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n    this.addDestroyableEventListener(this.eventService, events_1.Events.EVENT_COLUMN_EVERYTHING_CHANGED, this.onColumnEverything.bind(this));\n  };\n\n  InfiniteRowModel.prototype.onFilterChanged = function () {\n    if (this.gridOptionsWrapper.isEnableServerSideFilter()) {\n      this.reset();\n    }\n  };\n\n  InfiniteRowModel.prototype.onSortChanged = function () {\n    if (this.gridOptionsWrapper.isEnableServerSideSorting()) {\n      this.reset();\n    }\n  };\n\n  InfiniteRowModel.prototype.onColumnEverything = function () {\n    // if the columns get reset, then this means the sort order could be impacted\n    if (this.gridOptionsWrapper.isEnableServerSideSorting()) {\n      var resetRequired = void 0; // if cache params, we require reset only if sort model has changed. we don't need to check\n      // for filter model, as the filter manager will fire an event when columns change that result\n      // in the filter changing.\n\n      if (this.cacheParams) {\n        resetRequired = this.isSortModelDifferent();\n      } else {\n        // if no cacheParams, means first time creating the cache, so always create one\n        resetRequired = true;\n      }\n\n      if (resetRequired) {\n        this.reset();\n      }\n    }\n  };\n\n  InfiniteRowModel.prototype.isSortModelDifferent = function () {\n    return !utils_1.Utils.jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel());\n  };\n\n  InfiniteRowModel.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n  };\n\n  InfiniteRowModel.prototype.getType = function () {\n    return constants_1.Constants.ROW_MODEL_TYPE_INFINITE;\n  };\n\n  InfiniteRowModel.prototype.setDatasource = function (datasource) {\n    this.destroyDatasource();\n    this.datasource = datasource; // only reset if we have a valid datasource to working with\n\n    if (datasource) {\n      this.checkForDeprecated();\n      this.reset();\n    }\n  };\n\n  InfiniteRowModel.prototype.checkForDeprecated = function () {\n    var ds = this.datasource; // the number of concurrent loads we are allowed to the server\n\n    if (utils_1.Utils.exists(ds.maxConcurrentRequests)) {\n      console.error('ag-Grid: since version 5.1.x, maxConcurrentRequests is replaced with grid property maxConcurrentDatasourceRequests');\n    }\n\n    if (utils_1.Utils.exists(ds.maxPagesInCache)) {\n      console.error('ag-Grid: since version 5.1.x, maxPagesInCache is replaced with grid property maxPagesInPaginationCache');\n    }\n\n    if (utils_1.Utils.exists(ds.overflowSize)) {\n      console.error('ag-Grid: since version 5.1.x, overflowSize is replaced with grid property paginationOverflowSize');\n    }\n\n    if (utils_1.Utils.exists(ds.blockSize)) {\n      console.error('ag-Grid: since version 5.1.x, pageSize/blockSize is replaced with grid property infinitePageSize');\n    }\n  };\n\n  InfiniteRowModel.prototype.isEmpty = function () {\n    return utils_1.Utils.missing(this.infiniteCache);\n  };\n\n  InfiniteRowModel.prototype.isRowsToRender = function () {\n    return utils_1.Utils.exists(this.infiniteCache);\n  };\n\n  InfiniteRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n    return this.infiniteCache.getRowNodesInRange(firstInRange, lastInRange);\n  };\n\n  InfiniteRowModel.prototype.reset = function () {\n    // important to return here, as the user could be setting filter or sort before\n    // data-source is set\n    if (utils_1.Utils.missing(this.datasource)) {\n      return;\n    } // if user is providing id's, then this means we can keep the selection between datsource hits,\n    // as the rows will keep their unique id's even if, for example, server side sorting or filtering\n    // is done.\n\n\n    var userGeneratingIds = utils_1.Utils.exists(this.gridOptionsWrapper.getRowNodeIdFunc());\n\n    if (!userGeneratingIds) {\n      this.selectionController.reset();\n    }\n\n    this.resetCache();\n    var event = this.createModelUpdatedEvent();\n    this.eventService.dispatchEvent(event);\n  };\n\n  InfiniteRowModel.prototype.createModelUpdatedEvent = function () {\n    return {\n      type: events_1.Events.EVENT_MODEL_UPDATED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      // not sure if these should all be false - noticed if after implementing,\n      // maybe they should be true?\n      newPage: false,\n      newData: false,\n      keepRenderedRows: false,\n      animate: false\n    };\n  };\n\n  InfiniteRowModel.prototype.resetCache = function () {\n    // if not first time creating a cache, need to destroy the old one\n    this.destroyCache();\n    var maxConcurrentRequests = this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests();\n    var blockLoadDebounceMillis = this.gridOptionsWrapper.getBlockLoadDebounceMillis(); // there is a bi-directional dependency between the loader and the cache,\n    // so we create loader here, and then pass dependencies in setDependencies() method later\n\n    this.rowNodeBlockLoader = new rowNodeBlockLoader_1.RowNodeBlockLoader(maxConcurrentRequests, blockLoadDebounceMillis);\n    this.context.wireBean(this.rowNodeBlockLoader);\n    this.cacheParams = {\n      // the user provided datasource\n      datasource: this.datasource,\n      // sort and filter model\n      filterModel: this.filterManager.getFilterModel(),\n      sortModel: this.sortController.getSortModel(),\n      rowNodeBlockLoader: this.rowNodeBlockLoader,\n      // properties - this way we take a snapshot of them, so if user changes any, they will be\n      // used next time we create a new cache, which is generally after a filter or sort change,\n      // or a new datasource is set\n      maxConcurrentRequests: maxConcurrentRequests,\n      overflowSize: this.gridOptionsWrapper.getCacheOverflowSize(),\n      initialRowCount: this.gridOptionsWrapper.getInfiniteInitialRowCount(),\n      maxBlocksInCache: this.gridOptionsWrapper.getMaxBlocksInCache(),\n      blockSize: this.gridOptionsWrapper.getCacheBlockSize(),\n      rowHeight: this.gridOptionsWrapper.getRowHeightAsNumber(),\n      // the cache could create this, however it is also used by the pages, so handy to create it\n      // here as the settings are also passed to the pages\n      lastAccessedSequence: new utils_1.NumberSequence()\n    }; // set defaults\n\n    if (!(this.cacheParams.maxConcurrentRequests >= 1)) {\n      this.cacheParams.maxConcurrentRequests = 2;\n    } // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the\n    // server for one page at a time. so the default if not specified is 100.\n\n\n    if (!(this.cacheParams.blockSize >= 1)) {\n      this.cacheParams.blockSize = 100;\n    } // if user doesn't give initial rows to display, we assume zero\n\n\n    if (!(this.cacheParams.initialRowCount >= 1)) {\n      this.cacheParams.initialRowCount = 0;\n    } // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past\n    // the current page and request first row of next page\n\n\n    if (!(this.cacheParams.overflowSize >= 1)) {\n      this.cacheParams.overflowSize = 1;\n    }\n\n    this.infiniteCache = new infiniteCache_1.InfiniteCache(this.cacheParams);\n    this.context.wireBean(this.infiniteCache);\n    this.infiniteCache.addEventListener(rowNodeCache_1.RowNodeCache.EVENT_CACHE_UPDATED, this.onCacheUpdated.bind(this));\n  };\n\n  InfiniteRowModel.prototype.destroyCache = function () {\n    if (this.infiniteCache) {\n      this.infiniteCache.destroy();\n      this.infiniteCache = null;\n    }\n\n    if (this.rowNodeBlockLoader) {\n      this.rowNodeBlockLoader.destroy();\n      this.rowNodeBlockLoader = null;\n    }\n  };\n\n  InfiniteRowModel.prototype.onCacheUpdated = function () {\n    var event = this.createModelUpdatedEvent();\n    this.eventService.dispatchEvent(event);\n  };\n\n  InfiniteRowModel.prototype.getRow = function (rowIndex) {\n    return this.infiniteCache ? this.infiniteCache.getRow(rowIndex) : null;\n  };\n\n  InfiniteRowModel.prototype.getRowNode = function (id) {\n    var result = null;\n    this.forEachNode(function (rowNode) {\n      if (rowNode.id === id) {\n        result = rowNode;\n      }\n    });\n    return result;\n  };\n\n  InfiniteRowModel.prototype.forEachNode = function (callback) {\n    if (this.infiniteCache) {\n      this.infiniteCache.forEachNodeDeep(callback, new utils_1.NumberSequence());\n    }\n  };\n\n  InfiniteRowModel.prototype.getCurrentPageHeight = function () {\n    return this.getRowCount() * this.rowHeight;\n  };\n\n  InfiniteRowModel.prototype.getRowIndexAtPixel = function (pixel) {\n    if (this.rowHeight !== 0) {\n      // avoid divide by zero error\n      var rowIndexForPixel = Math.floor(pixel / this.rowHeight);\n\n      if (rowIndexForPixel > this.getPageLastRow()) {\n        return this.getPageLastRow();\n      } else {\n        return rowIndexForPixel;\n      }\n    } else {\n      return 0;\n    }\n  };\n\n  InfiniteRowModel.prototype.getPageFirstRow = function () {\n    return 0;\n  };\n\n  InfiniteRowModel.prototype.getPageLastRow = function () {\n    return this.infiniteCache ? this.infiniteCache.getVirtualRowCount() - 1 : 0;\n  };\n\n  InfiniteRowModel.prototype.getRowCount = function () {\n    return this.infiniteCache ? this.infiniteCache.getVirtualRowCount() : 0;\n  };\n\n  InfiniteRowModel.prototype.updateRowData = function (transaction) {\n    if (utils_1.Utils.exists(transaction.remove) || utils_1.Utils.exists(transaction.update)) {\n      console.warn('ag-Grid: updateRowData for InfiniteRowModel does not support remove or update, only add');\n      return;\n    }\n\n    if (utils_1.Utils.missing(transaction.addIndex)) {\n      console.warn('ag-Grid: updateRowData for InfiniteRowModel requires add and addIndex to be set');\n      return;\n    }\n\n    if (this.infiniteCache) {\n      this.infiniteCache.insertItemsAtIndex(transaction.addIndex, transaction.add);\n    }\n  };\n\n  InfiniteRowModel.prototype.isRowPresent = function (rowNode) {\n    return false;\n  };\n\n  InfiniteRowModel.prototype.refreshCache = function () {\n    if (this.infiniteCache) {\n      this.infiniteCache.refreshCache();\n    }\n  };\n\n  InfiniteRowModel.prototype.purgeCache = function () {\n    if (this.infiniteCache) {\n      this.infiniteCache.purgeCache();\n    }\n  };\n\n  InfiniteRowModel.prototype.getVirtualRowCount = function () {\n    if (this.infiniteCache) {\n      return this.infiniteCache.getVirtualRowCount();\n    } else {\n      return null;\n    }\n  };\n\n  InfiniteRowModel.prototype.isMaxRowFound = function () {\n    if (this.infiniteCache) {\n      return this.infiniteCache.isMaxRowFound();\n    }\n  };\n\n  InfiniteRowModel.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {\n    if (this.infiniteCache) {\n      this.infiniteCache.setVirtualRowCount(rowCount, maxRowFound);\n    }\n  };\n\n  InfiniteRowModel.prototype.getBlockState = function () {\n    if (this.rowNodeBlockLoader) {\n      return this.rowNodeBlockLoader.getBlockState();\n    } else {\n      return null;\n    }\n  };\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], InfiniteRowModel.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.Autowired('filterManager'), __metadata(\"design:type\", filterManager_1.FilterManager)], InfiniteRowModel.prototype, \"filterManager\", void 0);\n\n  __decorate([context_1.Autowired('sortController'), __metadata(\"design:type\", sortController_1.SortController)], InfiniteRowModel.prototype, \"sortController\", void 0);\n\n  __decorate([context_1.Autowired('selectionController'), __metadata(\"design:type\", selectionController_1.SelectionController)], InfiniteRowModel.prototype, \"selectionController\", void 0);\n\n  __decorate([context_1.Autowired('eventService'), __metadata(\"design:type\", eventService_1.EventService)], InfiniteRowModel.prototype, \"eventService\", void 0);\n\n  __decorate([context_1.Autowired('context'), __metadata(\"design:type\", context_1.Context)], InfiniteRowModel.prototype, \"context\", void 0);\n\n  __decorate([context_1.Autowired('gridApi'), __metadata(\"design:type\", gridApi_1.GridApi)], InfiniteRowModel.prototype, \"gridApi\", void 0);\n\n  __decorate([context_1.Autowired('columnApi'), __metadata(\"design:type\", columnApi_1.ColumnApi)], InfiniteRowModel.prototype, \"columnApi\", void 0);\n\n  __decorate([context_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], InfiniteRowModel.prototype, \"init\", null);\n\n  __decorate([context_1.PreDestroy, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], InfiniteRowModel.prototype, \"destroyDatasource\", null);\n\n  __decorate([context_1.PreDestroy, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], InfiniteRowModel.prototype, \"destroy\", null);\n\n  InfiniteRowModel = __decorate([context_1.Bean('rowModel')], InfiniteRowModel);\n  return InfiniteRowModel;\n}(beanStub_1.BeanStub);\n\nexports.InfiniteRowModel = InfiniteRowModel;","map":null,"metadata":{},"sourceType":"script"}