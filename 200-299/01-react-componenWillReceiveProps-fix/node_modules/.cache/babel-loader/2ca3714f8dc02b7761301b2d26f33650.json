{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar context_1 = require(\"../context/context\");\n\nvar columnController_1 = require(\"../columnController/columnController\");\n\nvar constants_1 = require(\"../constants\");\n\nvar utils_1 = require(\"../utils\");\n\nvar selectionController_1 = require(\"../selectionController\");\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar displayedGroupCreator_1 = require(\"../columnController/displayedGroupCreator\");\n\nvar columnFactory_1 = require(\"../columnController/columnFactory\");\n\nvar groupInstanceIdCreator_1 = require(\"../columnController/groupInstanceIdCreator\");\n\nvar columnGroup_1 = require(\"../entities/columnGroup\");\n\nvar pinnedRowModel_1 = require(\"../rowModels/pinnedRowModel\");\n\nvar autoGroupColService_1 = require(\"../columnController/autoGroupColService\");\n\nvar BaseGridSerializingSession =\n/** @class */\nfunction () {\n  function BaseGridSerializingSession(config) {\n    var columnController = config.columnController,\n        valueService = config.valueService,\n        gridOptionsWrapper = config.gridOptionsWrapper,\n        processCellCallback = config.processCellCallback,\n        processHeaderCallback = config.processHeaderCallback,\n        cellAndHeaderEscaper = config.cellAndHeaderEscaper;\n    this.columnController = columnController;\n    this.valueService = valueService;\n    this.gridOptionsWrapper = gridOptionsWrapper;\n    this.processCellCallback = processCellCallback;\n    this.processHeaderCallback = processHeaderCallback;\n    this.cellAndHeaderEscaper = cellAndHeaderEscaper;\n  }\n\n  BaseGridSerializingSession.prototype.extractHeaderValue = function (column) {\n    var nameForCol = this.getHeaderName(this.processHeaderCallback, column);\n\n    if (nameForCol === null || nameForCol === undefined) {\n      nameForCol = '';\n    }\n\n    return this.cellAndHeaderEscaper ? this.cellAndHeaderEscaper(nameForCol) : nameForCol;\n  };\n\n  BaseGridSerializingSession.prototype.extractRowCellValue = function (column, index, type, node) {\n    var isRowGrouping = this.columnController.getRowGroupColumns().length > 0;\n    var valueForCell;\n\n    if (node.group && isRowGrouping && index === 0) {\n      valueForCell = this.createValueForGroupNode(node);\n    } else {\n      valueForCell = this.valueService.getValue(column, node);\n    }\n\n    valueForCell = this.processCell(node, column, valueForCell, this.processCellCallback, type);\n\n    if (valueForCell === null || valueForCell === undefined) {\n      valueForCell = '';\n    }\n\n    return this.cellAndHeaderEscaper ? this.cellAndHeaderEscaper(valueForCell) : valueForCell;\n  };\n\n  BaseGridSerializingSession.prototype.getHeaderName = function (callback, column) {\n    if (callback) {\n      return callback({\n        column: column,\n        api: this.gridOptionsWrapper.getApi(),\n        columnApi: this.gridOptionsWrapper.getColumnApi(),\n        context: this.gridOptionsWrapper.getContext()\n      });\n    } else {\n      return this.columnController.getDisplayNameForColumn(column, 'csv', true);\n    }\n  };\n\n  BaseGridSerializingSession.prototype.createValueForGroupNode = function (node) {\n    var keys = [node.key];\n\n    while (node.parent) {\n      node = node.parent;\n      keys.push(node.key);\n    }\n\n    return keys.reverse().join(' -> ');\n  };\n\n  BaseGridSerializingSession.prototype.processCell = function (rowNode, column, value, processCellCallback, type) {\n    if (processCellCallback) {\n      return processCellCallback({\n        column: column,\n        node: rowNode,\n        value: value,\n        api: this.gridOptionsWrapper.getApi(),\n        columnApi: this.gridOptionsWrapper.getColumnApi(),\n        context: this.gridOptionsWrapper.getContext(),\n        type: type\n      });\n    } else {\n      return value;\n    }\n  };\n\n  return BaseGridSerializingSession;\n}();\n\nexports.BaseGridSerializingSession = BaseGridSerializingSession;\n\nvar GridSerializer =\n/** @class */\nfunction () {\n  function GridSerializer() {}\n\n  GridSerializer.prototype.serialize = function (gridSerializingSession, params) {\n    var dontSkipRows = function dontSkipRows() {\n      return false;\n    };\n\n    var skipGroups = params && params.skipGroups;\n    var skipHeader = params && params.skipHeader;\n    var columnGroups = params && params.columnGroups;\n    var skipFooters = params && params.skipFooters;\n    var skipPinnedTop = params && params.skipPinnedTop;\n    var skipPinnedBottom = params && params.skipPinnedBottom;\n    var includeCustomHeader = params && params.customHeader;\n    var includeCustomFooter = params && params.customFooter;\n    var allColumns = params && params.allColumns;\n    var onlySelected = params && params.onlySelected;\n    var columnKeys = params && params.columnKeys;\n    var onlySelectedAllPages = params && params.onlySelectedAllPages;\n    var rowSkipper = params && params.shouldRowBeSkipped || dontSkipRows;\n    var api = this.gridOptionsWrapper.getApi();\n    var skipSingleChildrenGroup = this.gridOptionsWrapper.isGroupRemoveSingleChildren();\n    var skipLowestSingleChildrenGroup = this.gridOptionsWrapper.isGroupRemoveLowestSingleChildren();\n    var context = this.gridOptionsWrapper.getContext(); // when in pivot mode, we always render cols on screen, never 'all columns'\n\n    var isPivotMode = this.columnController.isPivotMode();\n    var rowModelNormal = this.rowModel.getType() === constants_1.Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n    var onlySelectedNonStandardModel = !rowModelNormal && onlySelected;\n    var columnsToExport;\n\n    if (utils_1.Utils.existsAndNotEmpty(columnKeys)) {\n      columnsToExport = this.columnController.getGridColumns(columnKeys);\n    } else if (allColumns && !isPivotMode) {\n      // add auto group column for tree data\n      columnsToExport = this.gridOptionsWrapper.isTreeData() ? this.columnController.getGridColumns([autoGroupColService_1.AutoGroupColService.GROUP_AUTO_COLUMN_ID]) : [];\n      columnsToExport = columnsToExport.concat(this.columnController.getAllPrimaryColumns());\n    } else {\n      columnsToExport = this.columnController.getAllDisplayedColumns();\n    }\n\n    if (!columnsToExport || columnsToExport.length === 0) {\n      return '';\n    }\n\n    gridSerializingSession.prepare(columnsToExport);\n\n    if (includeCustomHeader) {\n      gridSerializingSession.addCustomHeader(params.customHeader);\n    } // first pass, put in the header names of the cols\n\n\n    if (columnGroups) {\n      var groupInstanceIdCreator = new groupInstanceIdCreator_1.GroupInstanceIdCreator();\n      var displayedGroups = this.displayedGroupCreator.createDisplayedGroups(columnsToExport, this.columnController.getGridBalancedTree(), groupInstanceIdCreator, null);\n      this.recursivelyAddHeaderGroups(displayedGroups, gridSerializingSession);\n    }\n\n    if (!skipHeader) {\n      var gridRowIterator_1 = gridSerializingSession.onNewHeaderRow();\n      columnsToExport.forEach(function (column, index) {\n        gridRowIterator_1.onColumn(column, index, null);\n      });\n    }\n\n    this.pinnedRowModel.forEachPinnedTopRow(processRow);\n\n    if (isPivotMode) {\n      if (this.rowModel.forEachPivotNode) {\n        this.rowModel.forEachPivotNode(processRow);\n      } else {\n        //Must be enterprise, so we can just loop through all the nodes\n        this.rowModel.forEachNode(processRow);\n      }\n    } else {\n      // onlySelectedAllPages: user doing pagination and wants selected items from\n      // other pages, so cannot use the standard row model as it won't have rows from\n      // other pages.\n      // onlySelectedNonStandardModel: if user wants selected in non standard row model\n      // (eg viewport) then again rowmodel cannot be used, so need to use selected instead.\n      if (onlySelectedAllPages || onlySelectedNonStandardModel) {\n        var selectedNodes = this.selectionController.getSelectedNodes();\n        selectedNodes.forEach(function (node) {\n          processRow(node);\n        });\n      } else {\n        // here is everything else - including standard row model and selected. we don't use\n        // the selection model even when just using selected, so that the result is the order\n        // of the rows appearing on the screen.\n        if (rowModelNormal) {\n          this.rowModel.forEachNodeAfterFilterAndSort(processRow);\n        } else {\n          this.rowModel.forEachNode(processRow);\n        }\n      }\n    }\n\n    this.pinnedRowModel.forEachPinnedBottomRow(processRow);\n\n    if (includeCustomFooter) {\n      gridSerializingSession.addCustomFooter(params.customFooter);\n    }\n\n    function processRow(node) {\n      var shouldSkipLowestGroup = skipLowestSingleChildrenGroup && node.leafGroup;\n      var shouldSkipCurrentGroup = node.allChildrenCount === 1 && (skipSingleChildrenGroup || shouldSkipLowestGroup);\n\n      if (node.group && (skipGroups || shouldSkipCurrentGroup)) {\n        return;\n      }\n\n      if (skipFooters && node.footer) {\n        return;\n      }\n\n      if (onlySelected && !node.isSelected()) {\n        return;\n      }\n\n      if (skipPinnedTop && node.rowPinned === 'top') {\n        return;\n      }\n\n      if (skipPinnedBottom && node.rowPinned === 'bottom') {\n        return;\n      } // if we are in pivotMode, then the grid will show the root node only\n      // if it's not a leaf group\n\n\n      var nodeIsRootNode = node.level === -1;\n\n      if (nodeIsRootNode && !node.leafGroup) {\n        return;\n      }\n\n      var shouldRowBeSkipped = rowSkipper({\n        node: node,\n        api: api,\n        context: context\n      });\n      if (shouldRowBeSkipped) return;\n      var rowAccumulator = gridSerializingSession.onNewBodyRow();\n      columnsToExport.forEach(function (column, index) {\n        rowAccumulator.onColumn(column, index, node);\n      });\n    }\n\n    return gridSerializingSession.parse();\n  };\n\n  GridSerializer.prototype.recursivelyAddHeaderGroups = function (displayedGroups, gridSerializingSession) {\n    var directChildrenHeaderGroups = [];\n    displayedGroups.forEach(function (columnGroupChild) {\n      var columnGroup = columnGroupChild;\n      if (!columnGroup.getChildren) return;\n      columnGroup.getChildren().forEach(function (it) {\n        return directChildrenHeaderGroups.push(it);\n      });\n    });\n\n    if (displayedGroups.length > 0 && displayedGroups[0] instanceof columnGroup_1.ColumnGroup) {\n      this.doAddHeaderHeader(gridSerializingSession, displayedGroups);\n    }\n\n    if (directChildrenHeaderGroups && directChildrenHeaderGroups.length > 0) {\n      this.recursivelyAddHeaderGroups(directChildrenHeaderGroups, gridSerializingSession);\n    }\n  };\n\n  GridSerializer.prototype.doAddHeaderHeader = function (gridSerializingSession, displayedGroups) {\n    var _this = this;\n\n    var gridRowIterator = gridSerializingSession.onNewHeaderGroupingRow();\n    var columnIndex = 0;\n    displayedGroups.forEach(function (columnGroupChild) {\n      var columnGroup = columnGroupChild;\n\n      var columnName = _this.columnController.getDisplayNameForColumnGroup(columnGroup, 'header');\n\n      gridRowIterator.onColumn(columnName, columnIndex++, columnGroup.getLeafColumns().length - 1);\n    });\n  };\n\n  __decorate([context_1.Autowired('displayedGroupCreator'), __metadata(\"design:type\", displayedGroupCreator_1.DisplayedGroupCreator)], GridSerializer.prototype, \"displayedGroupCreator\", void 0);\n\n  __decorate([context_1.Autowired('columnController'), __metadata(\"design:type\", columnController_1.ColumnController)], GridSerializer.prototype, \"columnController\", void 0);\n\n  __decorate([context_1.Autowired('rowModel'), __metadata(\"design:type\", Object)], GridSerializer.prototype, \"rowModel\", void 0);\n\n  __decorate([context_1.Autowired('pinnedRowModel'), __metadata(\"design:type\", pinnedRowModel_1.PinnedRowModel)], GridSerializer.prototype, \"pinnedRowModel\", void 0);\n\n  __decorate([context_1.Autowired('selectionController'), __metadata(\"design:type\", selectionController_1.SelectionController)], GridSerializer.prototype, \"selectionController\", void 0);\n\n  __decorate([context_1.Autowired('columnFactory'), __metadata(\"design:type\", columnFactory_1.ColumnFactory)], GridSerializer.prototype, \"columnFactory\", void 0);\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], GridSerializer.prototype, \"gridOptionsWrapper\", void 0);\n\n  GridSerializer = __decorate([context_1.Bean(\"gridSerializer\")], GridSerializer);\n  return GridSerializer;\n}();\n\nexports.GridSerializer = GridSerializer;\nvar RowType;\n\n(function (RowType) {\n  RowType[RowType[\"HEADER_GROUPING\"] = 0] = \"HEADER_GROUPING\";\n  RowType[RowType[\"HEADER\"] = 1] = \"HEADER\";\n  RowType[RowType[\"BODY\"] = 2] = \"BODY\";\n})(RowType = exports.RowType || (exports.RowType = {}));","map":null,"metadata":{},"sourceType":"script"}