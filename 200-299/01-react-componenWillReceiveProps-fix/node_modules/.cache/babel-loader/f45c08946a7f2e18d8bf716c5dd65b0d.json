{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar context_1 = require(\"../context/context\");\n\nvar logger_1 = require(\"../logger\");\n\nvar utils_1 = require(\"../utils\");\n\nvar eventService_1 = require(\"../eventService\");\n\nvar events_1 = require(\"../events\");\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar columnApi_1 = require(\"../columnController/columnApi\");\n\nvar gridApi_1 = require(\"../gridApi\");\n/** Adds drag listening onto an element. In ag-Grid this is used twice, first is resizing columns,\n * second is moving the columns and column groups around (ie the 'drag' part of Drag and Drop. */\n\n\nvar DragService =\n/** @class */\nfunction () {\n  function DragService() {\n    this.onMouseUpListener = this.onMouseUp.bind(this);\n    this.onMouseMoveListener = this.onMouseMove.bind(this);\n    this.onTouchEndListener = this.onTouchUp.bind(this);\n    this.onTouchMoveListener = this.onTouchMove.bind(this);\n    this.dragEndFunctions = [];\n    this.dragSources = [];\n  }\n\n  DragService.prototype.init = function () {\n    this.logger = this.loggerFactory.create('DragService');\n  };\n\n  DragService.prototype.destroy = function () {\n    this.dragSources.forEach(this.removeListener.bind(this));\n    this.dragSources.length = 0;\n  };\n\n  DragService.prototype.removeListener = function (dragSourceAndListener) {\n    var element = dragSourceAndListener.dragSource.eElement;\n    var mouseDownListener = dragSourceAndListener.mouseDownListener;\n    element.removeEventListener('mousedown', mouseDownListener); // remove touch listener only if it exists\n\n    if (dragSourceAndListener.touchEnabled) {\n      var touchStartListener = dragSourceAndListener.touchStartListener;\n      element.removeEventListener('touchstart', touchStartListener, {\n        passive: true\n      });\n    }\n  };\n\n  DragService.prototype.removeDragSource = function (params) {\n    var dragSourceAndListener = utils_1.Utils.find(this.dragSources, function (item) {\n      return item.dragSource === params;\n    });\n\n    if (!dragSourceAndListener) {\n      return;\n    }\n\n    this.removeListener(dragSourceAndListener);\n    utils_1.Utils.removeFromArray(this.dragSources, dragSourceAndListener);\n  };\n\n  DragService.prototype.setNoSelectToBody = function (noSelect) {\n    var usrDocument = this.gridOptionsWrapper.getDocument();\n    var eBody = usrDocument.querySelector('body');\n\n    if (utils_1.Utils.exists(eBody)) {\n      utils_1.Utils.addOrRemoveCssClass(eBody, 'ag-body-no-select', noSelect);\n    }\n  };\n\n  DragService.prototype.addDragSource = function (params, includeTouch) {\n    if (includeTouch === void 0) {\n      includeTouch = false;\n    }\n\n    var mouseListener = this.onMouseDown.bind(this, params);\n    params.eElement.addEventListener('mousedown', mouseListener);\n    var touchListener = null;\n    var suppressTouch = this.gridOptionsWrapper.isSuppressTouch();\n    var reallyIncludeTouch = includeTouch && !suppressTouch;\n\n    if (reallyIncludeTouch) {\n      touchListener = this.onTouchStart.bind(this, params);\n      params.eElement.addEventListener('touchstart', touchListener, {\n        passive: false\n      });\n    }\n\n    this.dragSources.push({\n      dragSource: params,\n      mouseDownListener: mouseListener,\n      touchStartListener: touchListener,\n      touchEnabled: includeTouch\n    });\n  }; // gets called whenever mouse down on any drag source\n\n\n  DragService.prototype.onTouchStart = function (params, touchEvent) {\n    var _this = this;\n\n    this.currentDragParams = params;\n    this.dragging = false;\n    var touch = touchEvent.touches[0];\n    this.touchLastTime = touch;\n    this.touchStart = touch;\n    touchEvent.preventDefault(); // we temporally add these listeners, for the duration of the drag, they\n    // are removed in touch end handling.\n\n    params.eElement.addEventListener('touchmove', this.onTouchMoveListener, {\n      passive: true\n    });\n    params.eElement.addEventListener('touchend', this.onTouchEndListener, {\n      passive: true\n    });\n    params.eElement.addEventListener('touchcancel', this.onTouchEndListener, {\n      passive: true\n    });\n    this.dragEndFunctions.push(function () {\n      params.eElement.removeEventListener('touchmove', _this.onTouchMoveListener, {\n        passive: true\n      });\n      params.eElement.removeEventListener('touchend', _this.onTouchEndListener, {\n        passive: true\n      });\n      params.eElement.removeEventListener('touchcancel', _this.onTouchEndListener, {\n        passive: true\n      });\n    }); // see if we want to start dragging straight away\n\n    if (params.dragStartPixels === 0) {\n      this.onCommonMove(touch, this.touchStart);\n    }\n  }; // gets called whenever mouse down on any drag source\n\n\n  DragService.prototype.onMouseDown = function (params, mouseEvent) {\n    var _this = this; // we ignore when shift key is pressed. this is for the range selection, as when\n    // user shift-clicks a cell, this should not be interpreted as the start of a drag.\n    // if (mouseEvent.shiftKey) { return; }\n\n\n    if (params.skipMouseEvent) {\n      if (params.skipMouseEvent(mouseEvent)) {\n        return;\n      }\n    } // if there are two elements with parent / child relationship, and both are draggable,\n    // when we drag the child, we should NOT drag the parent. an example of this is row moving\n    // and range selection - row moving should get preference when use drags the rowDrag component.\n\n\n    if (mouseEvent._alreadyProcessedByDragService) {\n      return;\n    }\n\n    mouseEvent._alreadyProcessedByDragService = true; // only interested in left button clicks\n\n    if (mouseEvent.button !== 0) {\n      return;\n    }\n\n    this.currentDragParams = params;\n    this.dragging = false;\n    this.mouseEventLastTime = mouseEvent;\n    this.mouseStartEvent = mouseEvent;\n    var usrDocument = this.gridOptionsWrapper.getDocument(); // we temporally add these listeners, for the duration of the drag, they\n    // are removed in mouseup handling.\n\n    usrDocument.addEventListener('mousemove', this.onMouseMoveListener);\n    usrDocument.addEventListener('mouseup', this.onMouseUpListener);\n    this.dragEndFunctions.push(function () {\n      usrDocument.removeEventListener('mousemove', _this.onMouseMoveListener);\n      usrDocument.removeEventListener('mouseup', _this.onMouseUpListener);\n    }); // see if we want to start dragging straight away\n\n    if (params.dragStartPixels === 0) {\n      this.onMouseMove(mouseEvent);\n    }\n  }; // returns true if the event is close to the original event by X pixels either vertically or horizontally.\n  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.\n\n\n  DragService.prototype.isEventNearStartEvent = function (currentEvent, startEvent) {\n    // by default, we wait 4 pixels before starting the drag\n    var requiredPixelDiff = utils_1.Utils.exists(this.currentDragParams.dragStartPixels) ? this.currentDragParams.dragStartPixels : 4;\n    return utils_1.Utils.areEventsNear(currentEvent, startEvent, requiredPixelDiff);\n  };\n\n  DragService.prototype.getFirstActiveTouch = function (touchList) {\n    for (var i = 0; i < touchList.length; i++) {\n      var matches = touchList[i].identifier === this.touchStart.identifier;\n\n      if (matches) {\n        return touchList[i];\n      }\n    }\n\n    return null;\n  };\n\n  DragService.prototype.onCommonMove = function (currentEvent, startEvent) {\n    if (!this.dragging) {\n      // if mouse hasn't travelled from the start position enough, do nothing\n      var toEarlyToDrag = !this.dragging && this.isEventNearStartEvent(currentEvent, startEvent);\n\n      if (toEarlyToDrag) {\n        return;\n      } else {\n        // alert(`started`);\n        this.dragging = true;\n        var event_1 = {\n          type: events_1.Events.EVENT_DRAG_STARTED,\n          api: this.gridApi,\n          columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event_1);\n        this.currentDragParams.onDragStart(startEvent);\n        this.setNoSelectToBody(true);\n      }\n    }\n\n    this.currentDragParams.onDragging(currentEvent);\n  };\n\n  DragService.prototype.onTouchMove = function (touchEvent) {\n    var touch = this.getFirstActiveTouch(touchEvent.touches);\n\n    if (!touch) {\n      return;\n    } // this.___statusPanel.setInfoText(Math.random() + ' onTouchMove preventDefault stopPropagation');\n    // if we don't preview default, then the browser will try and do it's own touch stuff,\n    // like do 'back button' (chrome does this) or scroll the page (eg drag column could  be confused\n    // with scroll page in the app)\n    // touchEvent.preventDefault();\n\n\n    this.onCommonMove(touch, this.touchStart);\n  }; // only gets called after a mouse down - as this is only added after mouseDown\n  // and is removed when mouseUp happens\n\n\n  DragService.prototype.onMouseMove = function (mouseEvent) {\n    this.onCommonMove(mouseEvent, this.mouseStartEvent);\n  };\n\n  DragService.prototype.onTouchUp = function (touchEvent) {\n    var touch = this.getFirstActiveTouch(touchEvent.changedTouches); // i haven't worked this out yet, but there is no matching touch\n    // when we get the touch up event. to get around this, we swap in\n    // the last touch. this is a hack to 'get it working' while we\n    // figure out what's going on, why we are not getting a touch in\n    // current event.\n\n    if (!touch) {\n      touch = this.touchLastTime;\n    } // if mouse was left up before we started to move, then this is a tap.\n    // we check this before onUpCommon as onUpCommon resets the dragging\n    // let tap = !this.dragging;\n    // let tapTarget = this.currentDragParams.eElement;\n\n\n    this.onUpCommon(touch); // if tap, tell user\n    // console.log(`${Math.random()} tap = ${tap}`);\n    // if (tap) {\n    //     tapTarget.click();\n    // }\n  };\n\n  DragService.prototype.onMouseUp = function (mouseEvent) {\n    this.onUpCommon(mouseEvent);\n  };\n\n  DragService.prototype.onUpCommon = function (eventOrTouch) {\n    if (this.dragging) {\n      this.dragging = false;\n      this.currentDragParams.onDragStop(eventOrTouch);\n      var event_2 = {\n        type: events_1.Events.EVENT_DRAG_STOPPED,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_2);\n    }\n\n    this.setNoSelectToBody(false);\n    this.mouseStartEvent = null;\n    this.mouseEventLastTime = null;\n    this.touchStart = null;\n    this.touchLastTime = null;\n    this.currentDragParams = null;\n    this.dragEndFunctions.forEach(function (func) {\n      return func();\n    });\n    this.dragEndFunctions.length = 0;\n  };\n\n  __decorate([context_1.Autowired('loggerFactory'), __metadata(\"design:type\", logger_1.LoggerFactory)], DragService.prototype, \"loggerFactory\", void 0);\n\n  __decorate([context_1.Autowired('eventService'), __metadata(\"design:type\", eventService_1.EventService)], DragService.prototype, \"eventService\", void 0);\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], DragService.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.Autowired('columnApi'), __metadata(\"design:type\", columnApi_1.ColumnApi)], DragService.prototype, \"columnApi\", void 0);\n\n  __decorate([context_1.Autowired('gridApi'), __metadata(\"design:type\", gridApi_1.GridApi)], DragService.prototype, \"gridApi\", void 0);\n\n  __decorate([context_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], DragService.prototype, \"init\", null);\n\n  __decorate([context_1.PreDestroy, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], DragService.prototype, \"destroy\", null);\n\n  DragService = __decorate([context_1.Bean('dragService')], DragService);\n  return DragService;\n}();\n\nexports.DragService = DragService;","map":null,"metadata":{},"sourceType":"script"}