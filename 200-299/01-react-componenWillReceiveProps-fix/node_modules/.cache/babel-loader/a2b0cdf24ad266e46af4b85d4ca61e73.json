{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"../utils\");\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar context_1 = require(\"../context/context\");\n\nvar dragAndDropService_1 = require(\"../dragAndDrop/dragAndDropService\");\n\nvar columnController_1 = require(\"../columnController/columnController\");\n\nvar eventService_1 = require(\"../eventService\");\n\nvar events_1 = require(\"../events\");\n\nvar headerRowComp_1 = require(\"./headerRowComp\");\n\nvar bodyDropTarget_1 = require(\"./bodyDropTarget\");\n\nvar column_1 = require(\"../entities/column\");\n\nvar scrollVisibleService_1 = require(\"../gridPanel/scrollVisibleService\");\n\nvar HeaderContainer =\n/** @class */\nfunction () {\n  function HeaderContainer(eContainer, eViewport, pinned) {\n    this.headerRowComps = [];\n    this.eContainer = eContainer;\n    this.pinned = pinned;\n    this.eViewport = eViewport;\n  }\n\n  HeaderContainer.prototype.registerGridComp = function (gridPanel) {\n    this.setupDragAndDrop(gridPanel);\n  };\n\n  HeaderContainer.prototype.forEachHeaderElement = function (callback) {\n    this.headerRowComps.forEach(function (headerRowComp) {\n      return headerRowComp.forEachHeaderElement(callback);\n    });\n  };\n\n  HeaderContainer.prototype.init = function () {\n    this.scrollWidth = this.gridOptionsWrapper.getScrollbarWidth(); // if value changes, then if not pivoting, we at least need to change the label eg from sum() to avg(),\n    // if pivoting, then the columns have changed\n\n    this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VALUE_CHANGED, this.onColumnValueChanged.bind(this));\n    this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.onColumnRowGroupChanged.bind(this));\n    this.eventService.addEventListener(events_1.Events.EVENT_GRID_COLUMNS_CHANGED, this.onGridColumnsChanged.bind(this));\n    this.eventService.addEventListener(events_1.Events.EVENT_SCROLL_VISIBILITY_CHANGED, this.onScrollVisibilityChanged.bind(this));\n    this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.onColumnResized.bind(this));\n    this.eventService.addEventListener(events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n  }; // if row group changes, that means we may need to add aggFunc's to the column headers,\n  // if the grid goes from no aggregation (ie no grouping) to grouping\n\n\n  HeaderContainer.prototype.onColumnRowGroupChanged = function () {\n    this.onGridColumnsChanged();\n  }; // if the agg func of a column changes, then we may need to update the agg func in columns header\n\n\n  HeaderContainer.prototype.onColumnValueChanged = function () {\n    this.onGridColumnsChanged();\n  };\n\n  HeaderContainer.prototype.onColumnResized = function () {\n    this.setWidthOfPinnedContainer();\n  };\n\n  HeaderContainer.prototype.onDisplayedColumnsChanged = function () {\n    this.setWidthOfPinnedContainer();\n  };\n\n  HeaderContainer.prototype.onScrollVisibilityChanged = function () {\n    this.setWidthOfPinnedContainer();\n  };\n\n  HeaderContainer.prototype.setWidthOfPinnedContainer = function () {\n    var pinningLeft = this.pinned === column_1.Column.PINNED_LEFT;\n    var pinningRight = this.pinned === column_1.Column.PINNED_RIGHT;\n\n    if (pinningLeft || pinningRight) {\n      // size to fit all columns\n      var width = pinningLeft ? this.columnController.getPinnedLeftContainerWidth() : this.columnController.getPinnedRightContainerWidth(); // if there is a scroll showing (and taking up space, so Windows, and not iOS)\n      // in the body, then we add extra space to keep header aligned with the body,\n      // as body width fits the cols and the scrollbar\n\n      var addPaddingForScrollbar = pinningLeft ? this.scrollVisibleService.isLeftVerticalScrollShowing() : this.scrollVisibleService.isRightVerticalScrollShowing();\n\n      if (addPaddingForScrollbar) {\n        width += this.scrollWidth;\n      }\n\n      this.eContainer.style.width = width + 'px';\n    }\n  };\n\n  HeaderContainer.prototype.destroy = function () {\n    this.removeHeaderRowComps();\n  }; // grid cols have changed - this also means the number of rows in the header can have\n  // changed. so we remove all the old rows and insert new ones for a complete refresh\n\n\n  HeaderContainer.prototype.onGridColumnsChanged = function () {\n    this.removeAndCreateAllRowComps();\n  };\n\n  HeaderContainer.prototype.removeAndCreateAllRowComps = function () {\n    this.removeHeaderRowComps();\n    this.createHeaderRowComps();\n  }; // we expose this for gridOptions.api.refreshHeader() to call\n\n\n  HeaderContainer.prototype.refresh = function () {\n    this.removeAndCreateAllRowComps();\n  };\n\n  HeaderContainer.prototype.setupDragAndDrop = function (gridComp) {\n    var dropContainer = this.eViewport ? this.eViewport : this.eContainer;\n    var bodyDropTarget = new bodyDropTarget_1.BodyDropTarget(this.pinned, dropContainer);\n    this.context.wireBean(bodyDropTarget);\n    bodyDropTarget.registerGridComp(gridComp);\n  };\n\n  HeaderContainer.prototype.removeHeaderRowComps = function () {\n    this.headerRowComps.forEach(function (headerRowComp) {\n      headerRowComp.destroy();\n    });\n    this.headerRowComps.length = 0;\n    utils_1.Utils.removeAllChildren(this.eContainer);\n  };\n\n  HeaderContainer.prototype.createHeaderRowComps = function () {\n    // if we are displaying header groups, then we have many rows here.\n    // go through each row of the header, one by one.\n    var rowCount = this.columnController.getHeaderRowCount();\n\n    for (var dept = 0; dept < rowCount; dept++) {\n      var groupRow = dept !== rowCount - 1;\n      var type = groupRow ? headerRowComp_1.HeaderRowType.COLUMN_GROUP : headerRowComp_1.HeaderRowType.COLUMN;\n      var headerRowComp = new headerRowComp_1.HeaderRowComp(dept, type, this.pinned, this.dropTarget);\n      this.context.wireBean(headerRowComp);\n      this.headerRowComps.push(headerRowComp);\n      this.eContainer.appendChild(headerRowComp.getGui());\n    }\n\n    var includeFloatingFilterRow = this.gridOptionsWrapper.isFloatingFilter() && !this.columnController.isPivotMode();\n\n    if (includeFloatingFilterRow) {\n      var headerRowComp = new headerRowComp_1.HeaderRowComp(rowCount, headerRowComp_1.HeaderRowType.FLOATING_FILTER, this.pinned, this.dropTarget);\n      this.context.wireBean(headerRowComp);\n      this.headerRowComps.push(headerRowComp);\n      this.eContainer.appendChild(headerRowComp.getGui());\n    }\n  };\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], HeaderContainer.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.Autowired('context'), __metadata(\"design:type\", context_1.Context)], HeaderContainer.prototype, \"context\", void 0);\n\n  __decorate([context_1.Autowired('$scope'), __metadata(\"design:type\", Object)], HeaderContainer.prototype, \"$scope\", void 0);\n\n  __decorate([context_1.Autowired('dragAndDropService'), __metadata(\"design:type\", dragAndDropService_1.DragAndDropService)], HeaderContainer.prototype, \"dragAndDropService\", void 0);\n\n  __decorate([context_1.Autowired('columnController'), __metadata(\"design:type\", columnController_1.ColumnController)], HeaderContainer.prototype, \"columnController\", void 0);\n\n  __decorate([context_1.Autowired('eventService'), __metadata(\"design:type\", eventService_1.EventService)], HeaderContainer.prototype, \"eventService\", void 0);\n\n  __decorate([context_1.Autowired('scrollVisibleService'), __metadata(\"design:type\", scrollVisibleService_1.ScrollVisibleService)], HeaderContainer.prototype, \"scrollVisibleService\", void 0);\n\n  __decorate([context_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], HeaderContainer.prototype, \"init\", null);\n\n  return HeaderContainer;\n}();\n\nexports.HeaderContainer = HeaderContainer;","map":null,"metadata":{},"sourceType":"script"}