{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"./constants\");\n\nvar FUNCTION_STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar FUNCTION_ARGUMENT_NAMES = /([^\\s,]+)/g;\nvar AG_GRID_STOP_PROPAGATION = '__ag_Grid_Stop_Propagation'; // util class, only used when debugging, for printing time to console\n\nvar Timer =\n/** @class */\nfunction () {\n  function Timer() {\n    this.timestamp = new Date().getTime();\n  }\n\n  Timer.prototype.print = function (msg) {\n    var duration = new Date().getTime() - this.timestamp;\n    console.info(msg + \" = \" + duration);\n    this.timestamp = new Date().getTime();\n  };\n\n  return Timer;\n}();\n\nexports.Timer = Timer;\n/** HTML Escapes. */\n\nvar HTML_ESCAPES = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\nvar reUnescapedHtml = /[&<>\"']/g;\n\nvar Utils =\n/** @class */\nfunction () {\n  function Utils() {} // if the key was passed before, then doesn't execute the func\n\n\n  Utils.doOnce = function (func, key) {\n    if (this.doOnceFlags[key]) {\n      return;\n    }\n\n    func();\n    this.doOnceFlags[key] = true;\n  }; // got from https://stackoverflow.com/questions/3944122/detect-left-mouse-button-press\n\n\n  Utils.isLeftClick = function (mouseEvent) {\n    if (\"buttons\" in mouseEvent) {\n      return mouseEvent.buttons == 1;\n    }\n\n    var button = mouseEvent.which || mouseEvent.button;\n    return button == 1;\n  }; // returns true if the event is close to the original event by X pixels either vertically or horizontally.\n  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.\n\n\n  Utils.areEventsNear = function (e1, e2, pixelCount) {\n    // by default, we wait 4 pixels before starting the drag\n    if (pixelCount === 0) {\n      return false;\n    }\n\n    var diffX = Math.abs(e1.clientX - e2.clientX);\n    var diffY = Math.abs(e1.clientY - e2.clientY);\n    return Math.max(diffX, diffY) <= pixelCount;\n  };\n\n  Utils.jsonEquals = function (val1, val2) {\n    var val1Json = val1 ? JSON.stringify(val1) : null;\n    var val2Json = val2 ? JSON.stringify(val2) : null;\n    var res = val1Json === val2Json;\n    return res;\n  };\n\n  Utils.shallowCompare = function (arr1, arr2) {\n    // if both are missing, then they are the same\n    if (this.missing(arr1) && this.missing(arr2)) {\n      return true;\n    } // if one is present, but other is missing, then then are different\n\n\n    if (this.missing(arr1) || this.missing(arr2)) {\n      return false;\n    }\n\n    if (arr1.length !== arr2.length) {\n      return false;\n    }\n\n    for (var i = 0; i < arr1.length; i++) {\n      if (arr1[i] !== arr2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Utils.getNameOfClass = function (TheClass) {\n    var funcNameRegex = /function (.{1,})\\(/;\n    var funcAsString = TheClass.toString();\n    var results = funcNameRegex.exec(funcAsString);\n    return results && results.length > 1 ? results[1] : \"\";\n  };\n\n  Utils.values = function (object) {\n    var result = [];\n    this.iterateObject(object, function (key, value) {\n      result.push(value);\n    });\n    return result;\n  };\n\n  Utils.getValueUsingField = function (data, field, fieldContainsDots) {\n    if (!field || !data) {\n      return;\n    } // if no '.', then it's not a deep value\n\n\n    if (!fieldContainsDots) {\n      return data[field];\n    } else {\n      // otherwise it is a deep value, so need to dig for it\n      var fields = field.split('.');\n      var currentObject = data;\n\n      for (var i = 0; i < fields.length; i++) {\n        currentObject = currentObject[fields[i]];\n\n        if (this.missing(currentObject)) {\n          return null;\n        }\n      }\n\n      return currentObject;\n    }\n  };\n\n  Utils.getAbsoluteHeight = function (el) {\n    var styles = window.getComputedStyle(el);\n    var margin = parseFloat(styles['marginTop']) + parseFloat(styles['marginBottom']);\n    return Math.ceil(el.offsetHeight + margin);\n  };\n\n  Utils.getAbsoluteWidth = function (el) {\n    var styles = window.getComputedStyle(el);\n    var margin = parseFloat(styles['marginLeft']) + parseFloat(styles['marginRight']);\n    return Math.ceil(el.offsetWidth + margin);\n  };\n\n  Utils.getScrollLeft = function (element, rtl) {\n    var scrollLeft = element.scrollLeft;\n\n    if (rtl) {\n      // Absolute value - for FF that reports RTL scrolls in negative numbers\n      scrollLeft = Math.abs(scrollLeft); // Get Chrome to return the same value as well\n\n      if (this.isBrowserChrome()) {\n        scrollLeft = element.scrollWidth - element.clientWidth - scrollLeft;\n      }\n    }\n\n    return scrollLeft;\n  };\n\n  Utils.cleanNumber = function (value) {\n    if (typeof value === 'string') {\n      value = parseInt(value, 10);\n    }\n\n    if (typeof value === 'number') {\n      value = Math.floor(value);\n    } else {\n      value = null;\n    }\n\n    return value;\n  };\n\n  Utils.setScrollLeft = function (element, value, rtl) {\n    if (rtl) {\n      // Chrome and Safari when doing RTL have the END position of the scroll as zero, not the start\n      if (this.isBrowserSafari() || this.isBrowserChrome()) {\n        value = element.scrollWidth - element.clientWidth - value;\n      } // Firefox uses negative numbers when doing RTL scrolling\n\n\n      if (this.isBrowserFirefox()) {\n        value *= -1;\n      }\n    }\n\n    element.scrollLeft = value;\n  };\n\n  Utils.iterateNamedNodeMap = function (map, callback) {\n    if (!map) {\n      return;\n    }\n\n    for (var i = 0; i < map.length; i++) {\n      var attr = map[i];\n      callback(attr.name, attr.value);\n    }\n  };\n\n  Utils.iterateObject = function (object, callback) {\n    if (this.missing(object)) {\n      return;\n    }\n\n    if (Array.isArray(object)) {\n      object.forEach(function (value, index) {\n        callback(index + '', value);\n      });\n    } else {\n      var keys = Object.keys(object);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = object[key];\n        callback(key, value);\n      }\n    }\n  };\n\n  Utils.cloneObject = function (object) {\n    var copy = {};\n    var keys = Object.keys(object);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = object[key];\n      copy[key] = value;\n    }\n\n    return copy;\n  };\n\n  Utils.deepCloneObject = function (object) {\n    return JSON.parse(JSON.stringify(object));\n  };\n\n  Utils.map = function (array, callback) {\n    var result = [];\n\n    for (var i = 0; i < array.length; i++) {\n      var item = array[i];\n      var mappedItem = callback(item, i);\n      result.push(mappedItem);\n    }\n\n    return result;\n  };\n\n  Utils.mapObject = function (object, callback) {\n    var result = [];\n    Utils.iterateObject(object, function (key, value) {\n      result.push(callback(value));\n    });\n    return result;\n  };\n\n  Utils.forEach = function (array, callback) {\n    if (!array) {\n      return;\n    }\n\n    for (var i = 0; i < array.length; i++) {\n      var value = array[i];\n      callback(value, i);\n    }\n  };\n\n  Utils.filter = function (array, callback) {\n    var result = [];\n    array.forEach(function (item) {\n      if (callback(item)) {\n        result.push(item);\n      }\n    });\n    return result;\n  };\n\n  Utils.getAllKeysInObjects = function (objects) {\n    var allValues = {};\n    objects.forEach(function (obj) {\n      if (obj) {\n        Object.keys(obj).forEach(function (key) {\n          return allValues[key] = null;\n        });\n      }\n    });\n    return Object.keys(allValues);\n  };\n\n  Utils.mergeDeep = function (dest, source) {\n    if (!this.exists(source)) return;\n    this.iterateObject(source, function (key, newValue) {\n      var oldValue = dest[key];\n\n      if (oldValue === newValue) {\n        return;\n      }\n\n      if (typeof oldValue === 'object' && typeof newValue === 'object') {\n        Utils.mergeDeep(oldValue, newValue);\n      } else {\n        dest[key] = newValue;\n      }\n    });\n  };\n\n  Utils.assign = function (object) {\n    var _this = this;\n\n    var sources = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      sources[_i - 1] = arguments[_i];\n    }\n\n    sources.forEach(function (source) {\n      if (_this.exists(source)) {\n        _this.iterateObject(source, function (key, value) {\n          object[key] = value;\n        });\n      }\n    });\n    return object;\n  };\n\n  Utils.parseYyyyMmDdToDate = function (yyyyMmDd, separator) {\n    try {\n      if (!yyyyMmDd) return null;\n      if (yyyyMmDd.indexOf(separator) === -1) return null;\n      var fields = yyyyMmDd.split(separator);\n      if (fields.length != 3) return null;\n      return new Date(Number(fields[0]), Number(fields[1]) - 1, Number(fields[2]));\n    } catch (e) {\n      return null;\n    }\n  };\n\n  Utils.serializeDateToYyyyMmDd = function (date, separator) {\n    if (!date) return null;\n    return date.getFullYear() + separator + Utils.pad(date.getMonth() + 1, 2) + separator + Utils.pad(date.getDate(), 2);\n  };\n\n  Utils.pad = function (num, totalStringSize) {\n    var asString = num + \"\";\n\n    while (asString.length < totalStringSize) {\n      asString = \"0\" + asString;\n    }\n\n    return asString;\n  };\n\n  Utils.pushAll = function (target, source) {\n    if (this.missing(source) || this.missing(target)) {\n      return;\n    }\n\n    source.forEach(function (func) {\n      return target.push(func);\n    });\n  };\n\n  Utils.createArrayOfNumbers = function (first, last) {\n    var result = [];\n\n    for (var i = first; i <= last; i++) {\n      result.push(i);\n    }\n\n    return result;\n  };\n\n  Utils.getFunctionParameters = function (func) {\n    var fnStr = func.toString().replace(FUNCTION_STRIP_COMMENTS, '');\n    var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(FUNCTION_ARGUMENT_NAMES);\n\n    if (result === null) {\n      return [];\n    } else {\n      return result;\n    }\n  };\n\n  Utils.find = function (collection, predicate, value) {\n    if (collection === null || collection === undefined) {\n      return null;\n    }\n\n    if (!Array.isArray(collection)) {\n      var objToArray = this.values(collection);\n      return this.find(objToArray, predicate, value);\n    }\n\n    var collectionAsArray = collection;\n    var firstMatchingItem;\n\n    for (var i = 0; i < collectionAsArray.length; i++) {\n      var item = collectionAsArray[i];\n\n      if (typeof predicate === 'string') {\n        if (item[predicate] === value) {\n          firstMatchingItem = item;\n          break;\n        }\n      } else {\n        var callback = predicate;\n\n        if (callback(item)) {\n          firstMatchingItem = item;\n          break;\n        }\n      }\n    }\n\n    return firstMatchingItem;\n  };\n\n  Utils.toStrings = function (array) {\n    return this.map(array, function (item) {\n      if (item === undefined || item === null || !item.toString) {\n        return null;\n      } else {\n        return item.toString();\n      }\n    });\n  };\n\n  Utils.iterateArray = function (array, callback) {\n    for (var index = 0; index < array.length; index++) {\n      var value = array[index];\n      callback(value, index);\n    }\n  }; //Returns true if it is a DOM node\n  //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n\n\n  Utils.isNode = function (o) {\n    return typeof Node === \"function\" ? o instanceof Node : o && typeof o === \"object\" && typeof o.nodeType === \"number\" && typeof o.nodeName === \"string\";\n  }; //Returns true if it is a DOM element\n  //taken from: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n\n\n  Utils.isElement = function (o) {\n    return typeof HTMLElement === \"function\" ? o instanceof HTMLElement : //DOM2\n    o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\";\n  };\n\n  Utils.isNodeOrElement = function (o) {\n    return this.isNode(o) || this.isElement(o);\n  }; // makes a copy of a node list into a list\n\n\n  Utils.copyNodeList = function (nodeList) {\n    var childCount = nodeList ? nodeList.length : 0;\n    var res = [];\n\n    for (var i = 0; i < childCount; i++) {\n      res.push(nodeList[i]);\n    }\n\n    return res;\n  };\n\n  Utils.isEventFromPrintableCharacter = function (event) {\n    var pressedChar = String.fromCharCode(event.charCode); // newline is an exception, as it counts as a printable character, but we don't\n    // want to start editing when it is pressed. without this check, if user is in chrome\n    // and editing a cell, and they press ctrl+enter, the cell stops editing, and then\n    // starts editing again with a blank value (two 'key down' events are fired). to\n    // test this, remove the line below, edit a cell in chrome and hit ctrl+enter while editing.\n    // https://ag-grid.atlassian.net/browse/AG-605\n\n    if (this.isKeyPressed(event, constants_1.Constants.KEY_NEW_LINE)) {\n      return false;\n    } // no allowed printable chars have alt or ctrl key combinations\n\n\n    if (event.altKey || event.ctrlKey) {\n      return false;\n    }\n\n    if (exports._.exists(event.key)) {\n      // modern browser will implement key, so we return if key is length 1, eg if it is 'a' for the\n      // a key, or '2' for the '2' key. non-printable characters have names, eg 'Enter' or 'Backspace'.\n      var printableCharacter = event.key.length === 1; // IE11 & Edge treat the numpad del key differently - with numlock on we get \"Del\" for key,\n      // so this addition checks if its IE11/Edge and handles that specific case the same was as all other browers\n\n      var numpadDelWithNumlockOnForEdgeOrIe = Utils.isNumpadDelWithNumlockOnForEdgeOrIe(event);\n      return printableCharacter || numpadDelWithNumlockOnForEdgeOrIe;\n    } else {\n      // otherwise, for older browsers, we test against a list of characters, which doesn't include\n      // accents for non-English, but don't care much, as most users are on modern browsers\n      return Utils.PRINTABLE_CHARACTERS.indexOf(pressedChar) >= 0;\n    }\n  }; //adds all type of change listeners to an element, intended to be a text field\n\n\n  Utils.addChangeListener = function (element, listener) {\n    element.addEventListener(\"changed\", listener);\n    element.addEventListener(\"paste\", listener);\n    element.addEventListener(\"input\", listener); // IE doesn't fire changed for special keys (eg delete, backspace), so need to\n    // listen for this further ones\n\n    element.addEventListener(\"keydown\", listener);\n    element.addEventListener(\"keyup\", listener);\n  }; //if value is undefined, null or blank, returns null, otherwise returns the value\n\n\n  Utils.makeNull = function (value) {\n    var valueNoType = value;\n\n    if (value === null || value === undefined || valueNoType === \"\") {\n      return null;\n    } else {\n      return value;\n    }\n  };\n\n  Utils.missing = function (value) {\n    return !this.exists(value);\n  };\n\n  Utils.missingOrEmpty = function (value) {\n    return this.missing(value) || value.length === 0;\n  };\n\n  Utils.missingOrEmptyObject = function (value) {\n    return this.missing(value) || Object.keys(value).length === 0;\n  };\n\n  Utils.exists = function (value, allowEmptyString) {\n    if (allowEmptyString === void 0) {\n      allowEmptyString = false;\n    }\n\n    return value != null && (value !== '' || allowEmptyString);\n  };\n\n  Utils.firstExistingValue = function () {\n    var values = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      values[_i] = arguments[_i];\n    }\n\n    for (var i = 0; i < values.length; i++) {\n      var value = values[i];\n      if (exports._.exists(value)) return value;\n    }\n\n    return null;\n  };\n\n  Utils.anyExists = function (values) {\n    if (values) {\n      for (var i = 0; i < values.length; i++) {\n        if (this.exists(values[i])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Utils.existsAndNotEmpty = function (value) {\n    return this.exists(value) && value.length > 0;\n  };\n\n  Utils.removeAllChildren = function (node) {\n    if (node) {\n      while (node.hasChildNodes()) {\n        node.removeChild(node.lastChild);\n      }\n    }\n  };\n\n  Utils.removeElement = function (parent, cssSelector) {\n    this.removeFromParent(parent.querySelector(cssSelector));\n  };\n\n  Utils.removeFromParent = function (node) {\n    if (node && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  };\n\n  Utils.isVisible = function (element) {\n    return element.offsetParent !== null;\n  };\n  /**\n   * loads the template and returns it as an element. makes up for no simple way in\n   * the dom api to load html directly, eg we cannot do this: document.createElement(template)\n   */\n\n\n  Utils.loadTemplate = function (template) {\n    var tempDiv = document.createElement(\"div\");\n    tempDiv.innerHTML = template;\n    return tempDiv.firstChild;\n  };\n\n  Utils.appendHtml = function (eContainer, htmlTemplate) {\n    if (eContainer.lastChild) {\n      // https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML\n      // we put the items at the start, so new items appear underneath old items,\n      // so when expanding/collapsing groups, the new rows don't go on top of the\n      // rows below that are moving our of the way\n      eContainer.insertAdjacentHTML('afterbegin', htmlTemplate);\n    } else {\n      eContainer.innerHTML = htmlTemplate;\n    }\n  };\n\n  Utils.addOrRemoveCssClass = function (element, className, addOrRemove) {\n    if (addOrRemove) {\n      this.addCssClass(element, className);\n    } else {\n      this.removeCssClass(element, className);\n    }\n  };\n\n  Utils.callIfPresent = function (func) {\n    if (func) {\n      func();\n    }\n  };\n\n  Utils.addCssClass = function (element, className) {\n    var _this = this;\n\n    if (!className || className.length === 0) {\n      return;\n    }\n\n    if (className.indexOf(' ') >= 0) {\n      className.split(' ').forEach(function (value) {\n        return _this.addCssClass(element, value);\n      });\n      return;\n    }\n\n    if (element.classList) {\n      if (!element.classList.contains(className)) {\n        element.classList.add(className);\n      }\n    } else {\n      if (element.className && element.className.length > 0) {\n        var cssClasses = element.className.split(' ');\n\n        if (cssClasses.indexOf(className) < 0) {\n          cssClasses.push(className);\n          element.className = cssClasses.join(' ');\n        }\n      } else {\n        element.className = className;\n      }\n    }\n  };\n\n  Utils.containsClass = function (element, className) {\n    if (element.classList) {\n      // for modern browsers\n      return element.classList.contains(className);\n    } else if (element.className) {\n      // for older browsers, check against the string of class names\n      // if only one class, can check for exact match\n      var onlyClass = element.className === className; // if many classes, check for class name, we have to pad with ' ' to stop other\n      // class names that are a substring of this class\n\n      var contains = element.className.indexOf(' ' + className + ' ') >= 0; // the padding above then breaks when it's the first or last class names\n\n      var startsWithClass = element.className.indexOf(className + ' ') === 0;\n      var endsWithClass = element.className.lastIndexOf(' ' + className) === element.className.length - className.length - 1;\n      return onlyClass || contains || startsWithClass || endsWithClass;\n    } else {\n      // if item is not a node\n      return false;\n    }\n  };\n\n  Utils.getElementAttribute = function (element, attributeName) {\n    if (element.attributes) {\n      if (element.attributes[attributeName]) {\n        var attribute = element.attributes[attributeName];\n        return attribute.value;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  };\n\n  Utils.offsetHeight = function (element) {\n    return element && element.clientHeight ? element.clientHeight : 0;\n  };\n\n  Utils.offsetWidth = function (element) {\n    return element && element.clientWidth ? element.clientWidth : 0;\n  };\n\n  Utils.sortNumberArray = function (numberArray) {\n    numberArray.sort(function (a, b) {\n      return a - b;\n    });\n  };\n\n  Utils.removeCssClass = function (element, className) {\n    if (element.classList) {\n      if (element.classList.contains(className)) {\n        element.classList.remove(className);\n      }\n    } else {\n      if (element.className && element.className.length > 0) {\n        var cssClasses = element.className.split(' ');\n\n        if (cssClasses.indexOf(className) >= 0) {\n          // remove all instances of the item, not just the first, in case it's in more than once\n          while (cssClasses.indexOf(className) >= 0) {\n            cssClasses.splice(cssClasses.indexOf(className), 1);\n          }\n\n          element.className = cssClasses.join(' ');\n        }\n      }\n    }\n  };\n\n  Utils.removeRepeatsFromArray = function (array, object) {\n    if (!array) {\n      return;\n    }\n\n    for (var index = array.length - 2; index >= 0; index--) {\n      var thisOneMatches = array[index] === object;\n      var nextOneMatches = array[index + 1] === object;\n\n      if (thisOneMatches && nextOneMatches) {\n        array.splice(index + 1, 1);\n      }\n    }\n  };\n\n  Utils.removeFromArray = function (array, object) {\n    if (array.indexOf(object) >= 0) {\n      array.splice(array.indexOf(object), 1);\n    }\n  };\n\n  Utils.removeAllFromArray = function (array, toRemove) {\n    toRemove.forEach(function (item) {\n      if (array.indexOf(item) >= 0) {\n        array.splice(array.indexOf(item), 1);\n      }\n    });\n  };\n\n  Utils.insertIntoArray = function (array, object, toIndex) {\n    array.splice(toIndex, 0, object);\n  };\n\n  Utils.insertArrayIntoArray = function (dest, src, toIndex) {\n    if (this.missing(dest) || this.missing(src)) {\n      return;\n    } // put items in backwards, otherwise inserted items end up in reverse order\n\n\n    for (var i = src.length - 1; i >= 0; i--) {\n      var item = src[i];\n      this.insertIntoArray(dest, item, toIndex);\n    }\n  };\n\n  Utils.moveInArray = function (array, objectsToMove, toIndex) {\n    var _this = this; // first take out it items from the array\n\n\n    objectsToMove.forEach(function (obj) {\n      _this.removeFromArray(array, obj);\n    }); // now add the objects, in same order as provided to us, that means we start at the end\n    // as the objects will be pushed to the right as they are inserted\n\n    objectsToMove.slice().reverse().forEach(function (obj) {\n      _this.insertIntoArray(array, obj, toIndex);\n    });\n  };\n\n  Utils.defaultComparator = function (valueA, valueB, accentedCompare) {\n    if (accentedCompare === void 0) {\n      accentedCompare = false;\n    }\n\n    var valueAMissing = valueA === null || valueA === undefined;\n    var valueBMissing = valueB === null || valueB === undefined; // this is for aggregations sum and avg, where the result can be a number that is wrapped.\n    // if we didn't do this, then the toString() value would be used, which would result in\n    // the strings getting used instead of the numbers.\n\n    if (valueA && valueA.toNumber) {\n      valueA = valueA.toNumber();\n    }\n\n    if (valueB && valueB.toNumber) {\n      valueB = valueB.toNumber();\n    }\n\n    if (valueAMissing && valueBMissing) {\n      return 0;\n    }\n\n    if (valueAMissing) {\n      return -1;\n    }\n\n    if (valueBMissing) {\n      return 1;\n    }\n\n    if (typeof valueA === \"string\") {\n      if (!accentedCompare) {\n        return doQuickCompare(valueA, valueB);\n      } else {\n        try {\n          // using local compare also allows chinese comparisons\n          return valueA.localeCompare(valueB);\n        } catch (e) {\n          // if something wrong with localeCompare, eg not supported\n          // by browser, then just continue with the quick one\n          return doQuickCompare(valueA, valueB);\n        }\n      }\n    }\n\n    if (valueA < valueB) {\n      return -1;\n    } else if (valueA > valueB) {\n      return 1;\n    } else {\n      return 0;\n    }\n\n    function doQuickCompare(a, b) {\n      return a > b ? 1 : a < b ? -1 : 0;\n    }\n  };\n\n  Utils.compareArrays = function (array1, array2) {\n    if (this.missing(array1) && this.missing(array2)) {\n      return true;\n    }\n\n    if (this.missing(array1) || this.missing(array2) || !array1 || !array2) {\n      return false;\n    }\n\n    if (array1.length !== array2.length) {\n      return false;\n    }\n\n    for (var i = 0; i < array1.length; i++) {\n      if (array1[i] !== array2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Utils.ensureDomOrder = function (eContainer, eChild, eChildBefore) {\n    // if already in right order, do nothing\n    if (eChildBefore && eChildBefore.nextSibling === eChild) {\n      return;\n    }\n\n    if (eChildBefore) {\n      if (eChildBefore.nextSibling) {\n        // insert between the eRowBefore and the row after it\n        eContainer.insertBefore(eChild, eChildBefore.nextSibling);\n      } else {\n        // if nextSibling is missing, means other row is at end, so just append new row at the end\n        eContainer.appendChild(eChild);\n      }\n    } else {\n      // otherwise put at start\n      if (eContainer.firstChild) {\n        // insert it at the first location\n        eContainer.insertBefore(eChild, eContainer.firstChild);\n      }\n    }\n  };\n\n  Utils.insertWithDomOrder = function (eContainer, eChild, eChildBefore) {\n    if (eChildBefore) {\n      if (eChildBefore.nextSibling) {\n        // insert between the eRowBefore and the row after it\n        eContainer.insertBefore(eChild, eChildBefore.nextSibling);\n      } else {\n        // if nextSibling is missing, means other row is at end, so just append new row at the end\n        eContainer.appendChild(eChild);\n      }\n    } else {\n      if (eContainer.firstChild) {\n        // insert it at the first location\n        eContainer.insertBefore(eChild, eContainer.firstChild);\n      } else {\n        // otherwise eContainer is empty, so just append it\n        eContainer.appendChild(eChild);\n      }\n    }\n  };\n\n  Utils.insertTemplateWithDomOrder = function (eContainer, htmlTemplate, eChildBefore) {\n    var res;\n\n    if (eChildBefore) {\n      // if previous element exists, just slot in after the previous element\n      eChildBefore.insertAdjacentHTML('afterend', htmlTemplate);\n      res = eChildBefore.nextSibling;\n    } else {\n      if (eContainer.firstChild) {\n        // insert it at the first location\n        eContainer.insertAdjacentHTML('afterbegin', htmlTemplate);\n      } else {\n        // otherwise eContainer is empty, so just append it\n        eContainer.innerHTML = htmlTemplate;\n      }\n\n      res = eContainer.firstChild;\n    }\n\n    return res;\n  };\n\n  Utils.every = function (items, callback) {\n    if (!items || items.length === 0) {\n      return true;\n    }\n\n    for (var i = 0; i < items.length; i++) {\n      if (!callback(items[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Utils.toStringOrNull = function (value) {\n    if (this.exists(value) && value.toString) {\n      return value.toString();\n    } else {\n      return null;\n    }\n  };\n\n  Utils.formatWidth = function (width) {\n    if (typeof width === \"number\") {\n      return width + \"px\";\n    } else {\n      return width;\n    }\n  };\n\n  Utils.formatNumberTwoDecimalPlacesAndCommas = function (value) {\n    if (typeof value !== 'number') {\n      return '';\n    } // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript\n\n\n    return (Math.round(value * 100) / 100).toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1,\");\n  }; // the native method number.toLocaleString(undefined, {minimumFractionDigits: 0}) puts in decimal places in IE,\n  // so we use this method instead\n\n\n  Utils.formatNumberCommas = function (value) {\n    if (typeof value !== 'number') {\n      return '';\n    } // took this from: http://blog.tompawlak.org/number-currency-formatting-javascript\n\n\n    return value.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, \"$1,\");\n  };\n\n  Utils.prependDC = function (parent, documentFragment) {\n    if (this.exists(parent.firstChild)) {\n      parent.insertBefore(documentFragment, parent.firstChild);\n    } else {\n      parent.appendChild(documentFragment);\n    }\n  };\n  /**\n   * If icon provided, use this (either a string, or a function callback).\n   * if not, then use the default icon from the theme\n   */\n\n\n  Utils.createIcon = function (iconName, gridOptionsWrapper, column) {\n    var iconContents = this.createIconNoSpan(iconName, gridOptionsWrapper, column);\n\n    if (iconContents.className.indexOf('ag-icon') > -1) {\n      return iconContents;\n    } else {\n      var eResult = document.createElement('span');\n      eResult.appendChild(iconContents);\n      return eResult;\n    }\n  };\n\n  Utils.createIconNoSpan = function (iconName, gridOptionsWrapper, column) {\n    var userProvidedIcon = null; // check col for icon first\n\n    var icons = column && column.getColDef().icons ? column.getColDef().icons : null;\n\n    if (icons) {\n      userProvidedIcon = icons[iconName];\n    } // it not in col, try grid options\n\n\n    if (!userProvidedIcon && gridOptionsWrapper.getIcons()) {\n      userProvidedIcon = gridOptionsWrapper.getIcons()[iconName];\n    } // now if user provided, use it\n\n\n    if (userProvidedIcon) {\n      var rendererResult = void 0;\n\n      if (typeof userProvidedIcon === 'function') {\n        rendererResult = userProvidedIcon();\n      } else if (typeof userProvidedIcon === 'string') {\n        rendererResult = userProvidedIcon;\n      } else {\n        throw new Error('icon from grid options needs to be a string or a function');\n      }\n\n      if (typeof rendererResult === 'string') {\n        return this.loadTemplate(rendererResult);\n      } else if (this.isNodeOrElement(rendererResult)) {\n        return rendererResult;\n      } else {\n        throw new Error('iconRenderer should return back a string or a dom object');\n      }\n    } else {\n      var span = document.createElement('span');\n      var cssClass = this.iconNameClassMap[iconName];\n\n      if (!cssClass) {\n        throw new Error(iconName + \" did not find class\");\n      }\n\n      span.setAttribute(\"class\", \"ag-icon ag-icon-\" + cssClass);\n      return span;\n    }\n  };\n\n  Utils.addStylesToElement = function (eElement, styles) {\n    var _this = this;\n\n    if (!styles) {\n      return;\n    }\n\n    Object.keys(styles).forEach(function (key) {\n      var keyCamelCase = _this.hyphenToCamelCase(key);\n\n      eElement.style[keyCamelCase] = styles[key];\n    });\n  };\n\n  Utils.isHorizontalScrollShowing = function (element) {\n    return element.clientWidth < element.scrollWidth;\n  };\n\n  Utils.isVerticalScrollShowing = function (element) {\n    return element.clientHeight < element.scrollHeight;\n  };\n\n  Utils.getMaxDivHeight = function () {\n    if (!document.body) {\n      return -1;\n    }\n\n    var res = 1000000; // FF reports the height back but still renders blank after ~6M px\n\n    var testUpTo = navigator.userAgent.toLowerCase().match(/firefox/) ? 6000000 : 1000000000;\n    var div = this.loadTemplate(\"<div/>\");\n    document.body.appendChild(div);\n\n    while (true) {\n      var test = res * 2;\n      div.style.height = test + 'px';\n\n      if (test > testUpTo || div.clientHeight !== test) {\n        break;\n      } else {\n        res = test;\n      }\n    }\n\n    document.body.removeChild(div);\n    return res;\n  };\n\n  Utils.getScrollbarWidth = function () {\n    var outer = document.createElement(\"div\");\n    outer.style.visibility = \"hidden\";\n    outer.style.width = \"100px\";\n    outer.style.msOverflowStyle = \"scrollbar\"; // needed for WinJS apps\n\n    document.body.appendChild(outer);\n    var widthNoScroll = outer.offsetWidth; // force scrollbars\n\n    outer.style.overflow = \"scroll\"; // add inner div\n\n    var inner = document.createElement(\"div\");\n    inner.style.width = \"100%\";\n    outer.appendChild(inner);\n    var widthWithScroll = inner.offsetWidth; // remove divs\n\n    outer.parentNode.removeChild(outer);\n    return widthNoScroll - widthWithScroll;\n  };\n\n  Utils.hasOverflowScrolling = function () {\n    var prefixes = ['webkit', 'moz', 'o', 'ms'];\n    var div = document.createElement('div');\n    var body = document.getElementsByTagName('body')[0];\n    var found = false;\n    var p;\n    body.appendChild(div);\n    div.setAttribute('style', prefixes.map(function (prefix) {\n      return \"-\" + prefix + \"-overflow-scrolling: touch\";\n    }).concat('overflow-scrolling: touch').join(';'));\n    var computedStyle = window.getComputedStyle(div);\n    if (computedStyle['overflowScrolling'] === 'touch') found = true;\n\n    if (!found) {\n      for (var _i = 0, prefixes_1 = prefixes; _i < prefixes_1.length; _i++) {\n        p = prefixes_1[_i];\n\n        if (computedStyle[p + \"OverflowScrolling\"] === 'touch') {\n          found = true;\n          break;\n        }\n      }\n    }\n\n    div.parentNode.removeChild(div);\n    return found;\n  };\n\n  Utils.isKeyPressed = function (event, keyToCheck) {\n    var pressedKey = event.which || event.keyCode;\n    return pressedKey === keyToCheck;\n  };\n\n  Utils.setVisible = function (element, visible) {\n    this.addOrRemoveCssClass(element, 'ag-hidden', !visible);\n  };\n\n  Utils.setHidden = function (element, hidden) {\n    this.addOrRemoveCssClass(element, 'ag-visibility-hidden', hidden);\n  };\n\n  Utils.isBrowserIE = function () {\n    if (this.isIE === undefined) {\n      this.isIE =\n      /*@cc_on!@*/\n      false || !!document.documentMode; // At least IE6\n    }\n\n    return this.isIE;\n  };\n\n  Utils.isBrowserEdge = function () {\n    if (this.isEdge === undefined) {\n      this.isEdge = !this.isBrowserIE() && !!window.StyleMedia;\n    }\n\n    return this.isEdge;\n  };\n\n  Utils.isBrowserSafari = function () {\n    if (this.isSafari === undefined) {\n      var anyWindow = window; // taken from https://github.com/ag-grid/ag-grid/issues/550\n\n      this.isSafari = Object.prototype.toString.call(anyWindow.HTMLElement).indexOf('Constructor') > 0 || function (p) {\n        return p ? p.toString() === \"[object SafariRemoteNotification]\" : false;\n      }(!anyWindow.safari || anyWindow.safari.pushNotification);\n    }\n\n    return this.isSafari;\n  };\n\n  Utils.isBrowserChrome = function () {\n    if (this.isChrome === undefined) {\n      // this is the old original we we did it, but it didn't work on android\n      // let anyWindow = <any> window;\n      // this.isChrome = !!anyWindow.chrome && !!anyWindow.chrome.webstore;\n      // this is the new way\n      // taken from https://stackoverflow.com/questions/4565112/javascript-how-to-find-out-if-the-user-browser-is-chrome\n      this.isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n    }\n\n    return this.isChrome;\n  };\n\n  Utils.isBrowserFirefox = function () {\n    if (this.isFirefox === undefined) {\n      var anyWindow = window;\n      this.isFirefox = typeof anyWindow.InstallTrigger !== 'undefined';\n    }\n\n    return this.isFirefox;\n  };\n\n  Utils.isUserAgentIPad = function () {\n    if (this.isIPad === undefined) {\n      // taken from https://davidwalsh.name/detect-ipad\n      this.isIPad = navigator.userAgent.match(/iPad|iPhone/i) != null;\n    }\n\n    return this.isIPad;\n  }; // srcElement is only available in IE. In all other browsers it is target\n  // http://stackoverflow.com/questions/5301643/how-can-i-make-event-srcelement-work-in-firefox-and-what-does-it-mean\n\n\n  Utils.getTarget = function (event) {\n    var eventNoType = event;\n    return eventNoType.target || eventNoType.srcElement;\n  };\n\n  Utils.isElementInEventPath = function (element, event) {\n    if (!event || !element) {\n      return false;\n    }\n\n    var path = exports._.getEventPath(event);\n\n    return path.indexOf(element) >= 0;\n  };\n\n  Utils.createEventPath = function (event) {\n    var res = [];\n\n    var pointer = exports._.getTarget(event);\n\n    while (pointer) {\n      res.push(pointer);\n      pointer = pointer.parentElement;\n    }\n\n    return res;\n  }; // firefox doesn't have event.path set, or any alternative to it, so we hack\n  // it in. this is needed as it's to late to work out the path when the item is\n  // removed from the dom. used by MouseEventService, where it works out if a click\n  // was from the current grid, or a detail grid (master / detail).\n\n\n  Utils.addAgGridEventPath = function (event) {\n    event.__agGridEventPath = this.getEventPath(event);\n  };\n\n  Utils.getEventPath = function (event) {\n    // https://stackoverflow.com/questions/39245488/event-path-undefined-with-firefox-and-vue-js\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event\n    var eventNoType = event;\n\n    if (eventNoType.deepPath) {\n      // IE supports deep path\n      return eventNoType.deepPath();\n    } else if (eventNoType.path) {\n      // Chrome supports path\n      return eventNoType.path;\n    } else if (eventNoType.composedPath) {\n      // Firefox supports composePath\n      return eventNoType.composedPath();\n    } else if (eventNoType.__agGridEventPath) {\n      // Firefox supports composePath\n      return eventNoType.__agGridEventPath;\n    } else {\n      // and finally, if none of the above worked,\n      // we create the path ourselves\n      return this.createEventPath(event);\n    }\n  };\n\n  Utils.forEachSnapshotFirst = function (list, callback) {\n    if (list) {\n      var arrayCopy = list.slice(0);\n      arrayCopy.forEach(callback);\n    }\n  }; // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code\n\n\n  Utils.getBodyWidth = function () {\n    if (document.body) {\n      return document.body.clientWidth;\n    }\n\n    if (window.innerHeight) {\n      return window.innerWidth;\n    }\n\n    if (document.documentElement && document.documentElement.clientWidth) {\n      return document.documentElement.clientWidth;\n    }\n\n    return -1;\n  }; // taken from: http://stackoverflow.com/questions/1038727/how-to-get-browser-width-using-javascript-code\n\n\n  Utils.getBodyHeight = function () {\n    if (document.body) {\n      return document.body.clientHeight;\n    }\n\n    if (window.innerHeight) {\n      return window.innerHeight;\n    }\n\n    if (document.documentElement && document.documentElement.clientHeight) {\n      return document.documentElement.clientHeight;\n    }\n\n    return -1;\n  };\n\n  Utils.setCheckboxState = function (eCheckbox, state) {\n    if (typeof state === 'boolean') {\n      eCheckbox.checked = state;\n      eCheckbox.indeterminate = false;\n    } else {\n      // isNodeSelected returns back undefined if it's a group and the children\n      // are a mix of selected and unselected\n      eCheckbox.indeterminate = true;\n    }\n  };\n\n  Utils.traverseNodesWithKey = function (nodes, callback) {\n    var keyParts = [];\n    recursiveSearchNodes(nodes);\n\n    function recursiveSearchNodes(currentNodes) {\n      currentNodes.forEach(function (node) {\n        // also checking for children for tree data\n        if (node.group || node.hasChildren()) {\n          keyParts.push(node.key);\n          var key = keyParts.join('|');\n          callback(node, key);\n          recursiveSearchNodes(node.childrenAfterGroup);\n          keyParts.pop();\n        }\n      });\n    }\n  }; // from https://gist.github.com/youssman/745578062609e8acac9f\n\n\n  Utils.camelCaseToHyphen = function (str) {\n    if (str === null || str === undefined) {\n      return null;\n    }\n\n    return str.replace(/([A-Z])/g, function (g) {\n      return '-' + g[0].toLowerCase();\n    });\n  }; // from https://stackoverflow.com/questions/6660977/convert-hyphens-to-camel-case-camelcase\n\n\n  Utils.hyphenToCamelCase = function (str) {\n    if (str === null || str === undefined) {\n      return null;\n    }\n\n    return str.replace(/-([a-z])/g, function (g) {\n      return g[1].toUpperCase();\n    });\n  }; // pas in an object eg: {color: 'black', top: '25px'} and it returns \"color: black; top: 25px;\" for html\n\n\n  Utils.cssStyleObjectToMarkup = function (stylesToUse) {\n    var _this = this;\n\n    if (!stylesToUse) {\n      return '';\n    }\n\n    var resParts = [];\n    this.iterateObject(stylesToUse, function (styleKey, styleValue) {\n      var styleKeyDashed = _this.camelCaseToHyphen(styleKey);\n\n      resParts.push(styleKeyDashed + \": \" + styleValue + \";\");\n    });\n    return resParts.join(' ');\n  };\n  /**\n   * From http://stackoverflow.com/questions/9716468/is-there-any-function-like-isnumeric-in-javascript-to-validate-numbers\n   */\n\n\n  Utils.isNumeric = function (value) {\n    if (value === '') return false;\n    return !isNaN(parseFloat(value)) && isFinite(value);\n  };\n\n  Utils.escape = function (toEscape) {\n    if (toEscape === null || toEscape === undefined || !toEscape.replace) {\n      return toEscape;\n    }\n\n    return toEscape.replace(reUnescapedHtml, function (chr) {\n      return HTML_ESCAPES[chr];\n    });\n  }; // Taken from here: https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\n\n  /**\n   * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is\n   * complicated, thus this doc is long and (hopefully) detailed enough to answer\n   * your questions.\n   *\n   * If you need to react to the mouse wheel in a predictable way, this code is\n   * like your bestest friend. * hugs *\n   *\n   * As of today, there are 4 DOM event types you can listen to:\n   *\n   *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)\n   *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari\n   *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!\n   *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003\n   *\n   * So what to do?  The is the best:\n   *\n   *   normalizeWheel.getEventType();\n   *\n   * In your event callback, use this code to get sane interpretation of the\n   * deltas.  This code will return an object with properties:\n   *\n   *   spinX   -- normalized spin speed (use for zoom) - x plane\n   *   spinY   -- \" - y plane\n   *   pixelX  -- normalized distance (to pixels) - x plane\n   *   pixelY  -- \" - y plane\n   *\n   * Wheel values are provided by the browser assuming you are using the wheel to\n   * scroll a web page by a number of lines or pixels (or pages).  Values can vary\n   * significantly on different platforms and browsers, forgetting that you can\n   * scroll at different speeds.  Some devices (like trackpads) emit more events\n   * at smaller increments with fine granularity, and some emit massive jumps with\n   * linear speed or acceleration.\n   *\n   * This code does its best to normalize the deltas for you:\n   *\n   *   - spin is trying to normalize how far the wheel was spun (or trackpad\n   *     dragged).  This is super useful for zoom support where you want to\n   *     throw away the chunky scroll steps on the PC and make those equal to\n   *     the slow and smooth tiny steps on the Mac. Key data: This code tries to\n   *     resolve a single slow step on a wheel to 1.\n   *\n   *   - pixel is normalizing the desired scroll delta in pixel units.  You'll\n   *     get the crazy differences between browsers, but at least it'll be in\n   *     pixels!\n   *\n   *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This\n   *     should translate to positive value zooming IN, negative zooming OUT.\n   *     This matches the newer 'wheel' event.\n   *\n   * Why are there spinX, spinY (or pixels)?\n   *\n   *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn\n   *     with a mouse.  It results in side-scrolling in the browser by default.\n   *\n   *   - spinY is what you expect -- it's the classic axis of a mouse wheel.\n   *\n   *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and\n   *     probably is by browsers in conjunction with fancy 3D controllers .. but\n   *     you know.\n   *\n   * Implementation info:\n   *\n   * Examples of 'wheel' event if you scroll slowly (down) by one step with an\n   * average mouse:\n   *\n   *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)\n   *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)\n   *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)\n   *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)\n   *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)\n   *\n   * On the trackpad:\n   *\n   *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)\n   *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)\n   *\n   * On other/older browsers.. it's more complicated as there can be multiple and\n   * also missing delta values.\n   *\n   * The 'wheel' event is more standard:\n   *\n   * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n   *\n   * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and\n   * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain\n   * backward compatibility with older events.  Those other values help us\n   * better normalize spin speed.  Example of what the browsers provide:\n   *\n   *                          | event.wheelDelta | event.detail\n   *        ------------------+------------------+--------------\n   *          Safari v5/OS X  |       -120       |       0\n   *          Safari v5/Win7  |       -120       |       0\n   *         Chrome v17/OS X  |       -120       |       0\n   *         Chrome v17/Win7  |       -120       |       0\n   *                IE9/Win7  |       -120       |   undefined\n   *         Firefox v4/OS X  |     undefined    |       1\n   *         Firefox v4/Win7  |     undefined    |       3\n   *\n   */\n\n\n  Utils.normalizeWheel = function (event) {\n    var PIXEL_STEP = 10;\n    var LINE_HEIGHT = 40;\n    var PAGE_HEIGHT = 800; // spinX, spinY\n\n    var sX = 0;\n    var sY = 0; // pixelX, pixelY\n\n    var pX = 0;\n    var pY = 0; // Legacy\n\n    if ('detail' in event) {\n      sY = event.detail;\n    }\n\n    if ('wheelDelta' in event) {\n      sY = -event.wheelDelta / 120;\n    }\n\n    if ('wheelDeltaY' in event) {\n      sY = -event.wheelDeltaY / 120;\n    }\n\n    if ('wheelDeltaX' in event) {\n      sX = -event.wheelDeltaX / 120;\n    } // side scrolling on FF with DOMMouseScroll\n\n\n    if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in event) {\n      pY = event.deltaY;\n    }\n\n    if ('deltaX' in event) {\n      pX = event.deltaX;\n    }\n\n    if ((pX || pY) && event.deltaMode) {\n      if (event.deltaMode == 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    } // Fall-back if spin cannot be determined\n\n\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  };\n  /**\n   * https://stackoverflow.com/questions/24004791/can-someone-explain-the-debounce-function-in-javascript\n   */\n\n\n  Utils.debounce = function (func, wait, immediate) {\n    if (immediate === void 0) {\n      immediate = false;\n    } // 'private' variable for instance\n    // The returned function will be able to reference this due to closure.\n    // Each call to the returned function will share this common timer.\n\n\n    var timeout; // Calling debounce returns a new anonymous function\n\n    return function () {\n      // reference the context and args for the setTimeout function\n      var context = this;\n      var args = arguments; // Should the function be called now? If immediate is true\n      //   and not already in a timeout then the answer is: Yes\n\n      var callNow = immediate && !timeout; // This is the basic debounce behaviour where you can call this\n      //   function several times, but it will only execute once\n      //   [before or after imposing a delay].\n      //   Each time the returned function is called, the timer starts over.\n\n      clearTimeout(timeout); // Set the new timeout\n\n      timeout = setTimeout(function () {\n        // Inside the timeout function, clear the timeout variable\n        // which will let the next execution run when in 'immediate' mode\n        timeout = null; // Check if the function already ran with the immediate flag\n\n        if (!immediate) {\n          // Call the original function with apply\n          // apply lets you define the 'this' object as well as the arguments\n          //    (both captured before setTimeout)\n          func.apply(context, args);\n        }\n      }, wait); // Immediate mode and no wait timer? Execute the function..\n\n      if (callNow) func.apply(context, args);\n    };\n  }; // a user once raised an issue - they said that when you opened a popup (eg context menu)\n  // and then clicked on a selection checkbox, the popup wasn't closed. this is because the\n  // popup listens for clicks on the body, however ag-grid WAS stopping propagation on the\n  // checkbox clicks (so the rows didn't pick them up as row selection selection clicks).\n  // to get around this, we have a pattern to stop propagation for the purposes of ag-Grid,\n  // but we still let the event pass back to teh body.\n\n\n  Utils.stopPropagationForAgGrid = function (event) {\n    event[AG_GRID_STOP_PROPAGATION] = true;\n  };\n\n  Utils.isStopPropagationForAgGrid = function (event) {\n    return event[AG_GRID_STOP_PROPAGATION] === true;\n  };\n\n  Utils.executeInAWhile = function (funcs) {\n    this.executeAfter(funcs, 400);\n  };\n\n  Utils.executeNextVMTurn = function (funcs) {\n    this.executeAfter(funcs, 0);\n  };\n\n  Utils.executeAfter = function (funcs, millis) {\n    if (funcs.length > 0) {\n      setTimeout(function () {\n        funcs.forEach(function (func) {\n          return func();\n        });\n      }, millis);\n    }\n  };\n\n  Utils.referenceCompare = function (left, right) {\n    if (left == null && right == null) return true;\n    if (left == null && right) return false;\n    if (left && right == null) return false;\n    return left === right;\n  };\n\n  Utils.get = function (source, expression, defaultValue) {\n    if (source == null) return defaultValue;\n\n    if (expression.indexOf('.') > -1) {\n      var fields = expression.split('.');\n      var thisKey = fields[0];\n      var nextValue = source[thisKey];\n\n      if (nextValue != null) {\n        return Utils.get(nextValue, fields.slice(1, fields.length).join('.'), defaultValue);\n      } else {\n        return defaultValue;\n      }\n    } else {\n      var nextValue = source[expression];\n      return nextValue != null ? nextValue : defaultValue;\n    }\n  };\n\n  Utils.addSafePassiveEventListener = function (eElement, event, listener) {\n    eElement.addEventListener(event, listener, Utils.passiveEvents.indexOf(event) > -1 ? {\n      passive: true\n    } : undefined);\n  };\n\n  Utils.camelCaseToHumanText = function (camelCase) {\n    if (!camelCase || camelCase == null) return null; // Who needs to learn how to code when you have stack overflow!\n    // from: https://stackoverflow.com/questions/15369566/putting-space-in-camel-case-string-using-regular-expression\n\n    var rex = /([A-Z])([A-Z])([a-z])|([a-z])([A-Z])/g;\n    var words = camelCase.replace(rex, '$1$4 $2$3$5').replace('.', ' ').split(' ');\n    return words.map(function (word) {\n      return word.substring(0, 1).toUpperCase() + (word.length > 1 ? word.substring(1, word.length) : '');\n    }).join(' ');\n  }; // displays a message to the browser. this is useful in iPad, where you can't easily see the console.\n  // so the javascript code can use this to give feedback. this is NOT intended to be called in production.\n  // it is intended the ag-Grid developer calls this to troubleshoot, but then takes out the calls before\n  // checking in.\n\n\n  Utils.message = function (msg) {\n    var eMessage = document.createElement('div');\n    eMessage.innerHTML = msg;\n    var eBox = document.querySelector('#__ag__message');\n\n    if (!eBox) {\n      var template = \"<div id=\\\"__ag__message\\\" style=\\\"display: inline-block; position: absolute; top: 0px; left: 0px; color: white; background-color: black; z-index: 20; padding: 2px; border: 1px solid darkred; height: 200px; overflow-y: auto;\\\"></div>\";\n      eBox = this.loadTemplate(template);\n\n      if (document.body) {\n        document.body.appendChild(eBox);\n      }\n    }\n\n    eBox.insertBefore(eMessage, eBox.children[0]); // eBox.appendChild(eMessage);\n  }; // gets called by: a) ClientSideNodeManager and b) GroupStage to do sorting.\n  // when in ClientSideNodeManager we always have indexes (as this sorts the items the\n  // user provided) but when in GroupStage, the nodes can contain filler nodes that\n  // don't have order id's\n\n\n  Utils.sortRowNodesByOrder = function (rowNodes, rowNodeOrder) {\n    if (!rowNodes) {\n      return;\n    }\n\n    rowNodes.sort(function (nodeA, nodeB) {\n      var positionA = rowNodeOrder[nodeA.id];\n      var positionB = rowNodeOrder[nodeB.id];\n      var aHasIndex = positionA !== undefined;\n      var bHasIndex = positionB !== undefined;\n      var bothNodesAreUserNodes = aHasIndex && bHasIndex;\n      var bothNodesAreFillerNodes = !aHasIndex && !bHasIndex;\n\n      if (bothNodesAreUserNodes) {\n        // when comparing two nodes the user has provided, they always\n        // have indexes\n        return positionA - positionB;\n      } else if (bothNodesAreFillerNodes) {\n        // when comparing two filler nodes, we have no index to compare them\n        // against, however we want this sorting to be deterministic, so that\n        // the rows don't jump around as the user does delta updates. so we\n        // want the same sort result. so we use the id - which doesn't make sense\n        // from a sorting point of view, but does give consistent behaviour between\n        // calls. otherwise groups jump around as delta updates are done.\n        return nodeA.id > nodeB.id ? 1 : -1;\n      } else if (aHasIndex) {\n        return 1;\n      } else {\n        return -1;\n      }\n    });\n  };\n\n  Utils.fuzzyCheckStrings = function (inputValues, validValues, allSuggestions) {\n    var _this = this;\n\n    var fuzzyMatches = {};\n    var invalidInputs = inputValues.filter(function (inputValue) {\n      return !validValues.some(function (validValue) {\n        return validValue === inputValue;\n      });\n    });\n\n    if (invalidInputs.length > 0) {\n      invalidInputs.forEach(function (invalidInput) {\n        return fuzzyMatches[invalidInput] = _this.fuzzySuggestions(invalidInput, validValues, allSuggestions);\n      });\n    }\n\n    return fuzzyMatches;\n  };\n\n  Utils.fuzzySuggestions = function (inputValue, validValues, allSuggestions) {\n    var thisSuggestions = allSuggestions.slice(0);\n    thisSuggestions.sort(function (suggestedValueLeft, suggestedValueRight) {\n      var leftDifference = exports._.string_similarity(suggestedValueLeft.toLowerCase(), inputValue.toLowerCase());\n\n      var rightDifference = exports._.string_similarity(suggestedValueRight.toLowerCase(), inputValue.toLowerCase());\n\n      return leftDifference > rightDifference ? -1 : leftDifference === rightDifference ? 0 : 1;\n    });\n    return thisSuggestions;\n  }; //Algorithm to do fuzzy search\n  //https://stackoverflow.com/questions/23305000/javascript-fuzzy-search-that-makes-sense\n\n\n  Utils.get_bigrams = function (from) {\n    var s = from.toLowerCase();\n    var v = new Array(s.length - 1);\n    var i;\n    var j;\n    var ref;\n\n    for (i = j = 0, ref = v.length; j <= ref; i = j += 1) {\n      v[i] = s.slice(i, i + 2);\n    }\n\n    return v;\n  };\n\n  Utils.isNumpadDelWithNumlockOnForEdgeOrIe = function (event) {\n    if (Utils.isBrowserEdge() || Utils.isBrowserIE()) {\n      return event.key === Utils.NUMPAD_DEL_NUMLOCK_ON_KEY && event.charCode === Utils.NUMPAD_DEL_NUMLOCK_ON_CHARCODE;\n    }\n\n    return false;\n  };\n\n  Utils.PRINTABLE_CHARACTERS = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890!\"$%^&*()_+-=[];\\'#,./\\\\|<>?:@~{}';\n  Utils.NUMPAD_DEL_NUMLOCK_ON_KEY = 'Del';\n  Utils.NUMPAD_DEL_NUMLOCK_ON_CHARCODE = 46;\n  Utils.doOnceFlags = {};\n\n  Utils.compose = function () {\n    var fns = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fns[_i] = arguments[_i];\n    }\n\n    return function (arg) {\n      return fns.reduce(function (composed, f) {\n        return f(composed);\n      }, arg);\n    };\n  };\n\n  Utils.decToHex = function (number, bytes) {\n    var hex = '';\n\n    for (var i = 0; i < bytes; i++) {\n      hex += String.fromCharCode(number & 0xff);\n      number >>>= 8;\n    }\n\n    return hex;\n  };\n\n  Utils.utf8_encode = function (s) {\n    var utftext = '';\n    s = s.replace(/\\r\\n/g, \"\\n\");\n\n    for (var n = 0, len = s.length; n < len; n++) {\n      var c = s.charCodeAt(n);\n\n      if (c < 128) {\n        utftext += String.fromCharCode(c);\n      } else if (c > 127 && c < 2048) {\n        utftext += String.fromCharCode(c >> 6 | 192);\n        utftext += String.fromCharCode(c & 63 | 128);\n      } else {\n        utftext += String.fromCharCode(c >> 12 | 224);\n        utftext += String.fromCharCode(c >> 6 & 63 | 128);\n        utftext += String.fromCharCode(c & 63 | 128);\n      }\n    }\n\n    return utftext;\n  }; // static prepend(parent: HTMLElement, child: HTMLElement): void {\n  //     if (this.exists(parent.firstChild)) {\n  //         parent.insertBefore(child, parent.firstChild);\n  //     } else {\n  //         parent.appendChild(child);\n  //     }\n  // }\n\n\n  Utils.iconNameClassMap = {\n    columnMovePin: 'pin',\n    columnMoveAdd: 'plus',\n    columnMoveHide: 'eye-slash',\n    columnMoveMove: 'arrows',\n    columnMoveLeft: 'left',\n    columnMoveRight: 'right',\n    columnMoveGroup: 'group',\n    columnMoveValue: 'aggregation',\n    columnMovePivot: 'pivot',\n    dropNotAllowed: 'not-allowed',\n    groupContracted: 'expanded',\n    groupExpanded: 'contracted',\n    checkboxChecked: 'checkbox-checked',\n    checkboxUnchecked: 'checkbox-unchecked',\n    checkboxIndeterminate: 'checkbox-indeterminate',\n    checkboxCheckedReadOnly: 'checkbox-checked-readonly',\n    checkboxUncheckedReadOnly: 'checkbox-unchecked-readonly',\n    checkboxIndeterminateReadOnly: 'checkbox-indeterminate-readonly',\n    groupLoading: 'loading',\n    menu: 'menu',\n    filter: 'filter',\n    columns: 'columns',\n    menuPin: 'pin',\n    menuValue: 'aggregation',\n    menuAddRowGroup: 'group',\n    menuRemoveRowGroup: 'group',\n    clipboardCopy: 'copy',\n    clipboardCut: 'cut',\n    clipboardPaste: 'paste',\n    pivotPanel: 'pivot',\n    rowGroupPanel: 'group',\n    valuePanel: 'aggregation',\n    columnGroupOpened: 'expanded',\n    columnGroupClosed: 'contracted',\n    columnSelectClosed: 'tree-closed',\n    columnSelectOpen: 'tree-open',\n    // from deprecated header, remove at some point\n    sortAscending: 'asc',\n    sortDescending: 'desc',\n    sortUnSort: 'none'\n  };\n  Utils.passiveEvents = ['touchstart', 'touchend', 'touchmove', 'touchcancel'];\n\n  Utils.string_similarity = function (str1, str2) {\n    if (str1.length > 0 && str2.length > 0) {\n      var pairs1 = Utils.get_bigrams(str1);\n      var pairs2 = Utils.get_bigrams(str2);\n      var union = pairs1.length + pairs2.length;\n      var hit_count = 0;\n      var j = void 0;\n      var len = void 0;\n\n      for (j = 0, len = pairs1.length; j < len; j++) {\n        var x = pairs1[j];\n        var k = void 0;\n        var len1 = void 0;\n\n        for (k = 0, len1 = pairs2.length; k < len1; k++) {\n          var y = pairs2[k];\n\n          if (x === y) {\n            hit_count++;\n          }\n        }\n      }\n\n      if (hit_count > 0) {\n        return 2.0 * hit_count / union;\n      }\n    }\n\n    return 0.0;\n  };\n\n  return Utils;\n}();\n\nexports.Utils = Utils;\n\nvar NumberSequence =\n/** @class */\nfunction () {\n  function NumberSequence(initValue, step) {\n    if (initValue === void 0) {\n      initValue = 0;\n    }\n\n    if (step === void 0) {\n      step = 1;\n    }\n\n    this.nextValue = initValue;\n    this.step = step;\n  }\n\n  NumberSequence.prototype.next = function () {\n    var valToReturn = this.nextValue;\n    this.nextValue += this.step;\n    return valToReturn;\n  };\n\n  NumberSequence.prototype.peek = function () {\n    return this.nextValue;\n  };\n\n  NumberSequence.prototype.skip = function (count) {\n    this.nextValue += count;\n  };\n\n  return NumberSequence;\n}();\n\nexports.NumberSequence = NumberSequence;\nexports._ = Utils;\nvar PromiseStatus;\n\n(function (PromiseStatus) {\n  PromiseStatus[PromiseStatus[\"IN_PROGRESS\"] = 0] = \"IN_PROGRESS\";\n  PromiseStatus[PromiseStatus[\"RESOLVED\"] = 1] = \"RESOLVED\";\n})(PromiseStatus = exports.PromiseStatus || (exports.PromiseStatus = {}));\n\nvar Promise =\n/** @class */\nfunction () {\n  function Promise(callback) {\n    this.status = PromiseStatus.IN_PROGRESS;\n    this.resolution = null;\n    this.listOfWaiters = [];\n    callback(this.onDone.bind(this), this.onReject.bind(this));\n  }\n\n  Promise.all = function (toCombine) {\n    return new Promise(function (resolve) {\n      var combinedValues = [];\n      var remainingToResolve = toCombine.length;\n      toCombine.forEach(function (source, index) {\n        source.then(function (sourceResolved) {\n          remainingToResolve--;\n          combinedValues[index] = sourceResolved;\n\n          if (remainingToResolve == 0) {\n            resolve(combinedValues);\n          }\n        });\n        combinedValues.push(null); // spl todo: review with Alberto - why?\n      });\n    });\n  };\n\n  Promise.resolve = function (value) {\n    return new Promise(function (resolve) {\n      return resolve(value);\n    });\n  };\n\n  Promise.external = function () {\n    var capture;\n    var promise = new Promise(function (resolve) {\n      capture = resolve;\n    });\n    return {\n      promise: promise,\n      resolve: function resolve(value) {\n        capture(value);\n      }\n    };\n  };\n\n  Promise.prototype.then = function (func) {\n    if (this.status === PromiseStatus.IN_PROGRESS) {\n      this.listOfWaiters.push(func);\n    } else {\n      func(this.resolution);\n    }\n  };\n\n  Promise.prototype.firstOneOnly = function (func) {\n    if (this.status === PromiseStatus.IN_PROGRESS) {\n      if (this.listOfWaiters.length === 0) {\n        this.listOfWaiters.push(func);\n      }\n    } else {\n      func(this.resolution);\n    }\n  };\n\n  Promise.prototype.map = function (adapter) {\n    var _this = this;\n\n    return new Promise(function (resolve) {\n      _this.then(function (unmapped) {\n        resolve(adapter(unmapped));\n      });\n    });\n  };\n\n  Promise.prototype.resolveNow = function (ifNotResolvedValue, ifResolved) {\n    if (this.status == PromiseStatus.IN_PROGRESS) return ifNotResolvedValue;\n    return ifResolved(this.resolution);\n  };\n\n  Promise.prototype.onDone = function (value) {\n    this.status = PromiseStatus.RESOLVED;\n    this.resolution = value;\n    this.listOfWaiters.forEach(function (waiter) {\n      return waiter(value);\n    });\n  };\n\n  Promise.prototype.onReject = function (params) {\n    console.warn('TBI');\n  };\n\n  return Promise;\n}();\n\nexports.Promise = Promise;","map":null,"metadata":{},"sourceType":"script"}