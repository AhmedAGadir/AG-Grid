{"ast":null,"code":"// ag-grid-react v19.1.2\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar React = require(\"react\");\n\nvar ReactDOM = require(\"react-dom\");\n\nvar AgGrid = require(\"ag-grid-community\");\n\nvar ag_grid_community_1 = require(\"ag-grid-community\");\n\nvar AgReactComponent =\n/** @class */\nfunction () {\n  function AgReactComponent(reactComponent, parentComponent) {\n    this.reactComponent = reactComponent;\n    this.parentComponent = parentComponent;\n  }\n\n  AgReactComponent.prototype.getFrameworkComponentInstance = function () {\n    return this.componentInstance;\n  };\n\n  AgReactComponent.prototype.init = function (params) {\n    var _this = this;\n\n    return new ag_grid_community_1.Promise(function (resolve) {\n      _this.eParentElement = document.createElement('div');\n      AgGrid.Utils.addCssClass(_this.eParentElement, 'ag-react-container'); // so user can have access to the react container,\n      // to add css class or style\n\n      params.reactContainer = _this.eParentElement; // at some point soon unstable_renderSubtreeIntoContainer is going to be dropped (and in a minor release at that)\n      // this uses the existing mechanism as long as possible, but switches over to using Portals when\n      // unstable_renderSubtreeIntoContainer is no longer an option\n\n      var reactLegacy = _this.useLegacyReact();\n\n      if (reactLegacy) {\n        _this.createReactComponentLegacy(params, resolve);\n      } else {\n        _this.createReactComponent(params, resolve);\n      }\n    });\n  };\n\n  AgReactComponent.prototype.useLegacyReact = function () {\n    // force use of react next (ie portals) if unstable_renderSubtreeIntoContainer is no longer present\n    // or if the user elects to try it\n    return typeof ReactDOM.unstable_renderSubtreeIntoContainer !== \"function\" || this.parentComponent && this.parentComponent.gridOptions && !this.parentComponent.gridOptions.reactNext;\n  };\n\n  AgReactComponent.prototype.getGui = function () {\n    return this.eParentElement;\n  };\n\n  AgReactComponent.prototype.destroy = function () {\n    ReactDOM.unmountComponentAtNode(this.eParentElement);\n  };\n\n  AgReactComponent.prototype.createReactComponentLegacy = function (params, resolve) {\n    var self = this;\n    var ReactComponent = React.createElement(this.reactComponent, params);\n\n    if (!this.parentComponent) {\n      // MUST be a function, not an arrow function\n      ReactDOM.render(ReactComponent, this.eParentElement, function () {\n        self.componentInstance = this;\n        resolve(null);\n      });\n    } else {\n      // MUST be a function, not an arrow function\n      ReactDOM.unstable_renderSubtreeIntoContainer(this.parentComponent, ReactComponent, this.eParentElement, function () {\n        self.componentInstance = this;\n        resolve(null);\n      });\n    }\n  };\n\n  AgReactComponent.prototype.createReactComponent = function (params, resolve) {\n    var _this = this; // when using portals & redux with HOCs you need to manually add the store to the props\n    // wrapping the component with connect isn't sufficient\n\n\n    var reduxStore = params.agGridReact.props.reduxStore;\n\n    if (reduxStore) {\n      params.store = reduxStore;\n    } // grab hold of the actual instance created - we use a react ref for this as there is no other mechanism to\n    // retrieve the created instance from either createPortal or render\n\n\n    params.ref = function (element) {\n      _this.componentInstance = element;\n    };\n\n    var ReactComponent = React.createElement(this.reactComponent, params);\n    var portal = ReactDOM.createPortal(ReactComponent, this.eParentElement); // MUST be a function, not an arrow function\n\n    ReactDOM.render(portal, this.eParentElement, function () {\n      resolve(null);\n    });\n  };\n\n  return AgReactComponent;\n}();\n\nexports.AgReactComponent = AgReactComponent;","map":null,"metadata":{},"sourceType":"script"}