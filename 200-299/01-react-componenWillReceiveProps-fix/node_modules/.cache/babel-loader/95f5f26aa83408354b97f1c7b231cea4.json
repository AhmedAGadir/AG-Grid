{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar gridOptionsWrapper_1 = require(\"./gridOptionsWrapper\");\n\nvar columnController_1 = require(\"./columnController/columnController\");\n\nvar eventService_1 = require(\"./eventService\");\n\nvar logger_1 = require(\"./logger\");\n\nvar events_1 = require(\"./events\");\n\nvar context_1 = require(\"./context/context\");\n\nvar context_2 = require(\"./context/context\");\n\nvar context_3 = require(\"./context/context\");\n\nvar context_4 = require(\"./context/context\");\n\nvar AlignedGridsService =\n/** @class */\nfunction () {\n  function AlignedGridsService() {\n    // flag to mark if we are consuming. to avoid cyclic events (ie other grid firing back to master\n    // while processing a master event) we mark this if consuming an event, and if we are, then\n    // we don't fire back any events.\n    this.consuming = false;\n  }\n\n  AlignedGridsService.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('AlignedGridsService');\n  };\n\n  AlignedGridsService.prototype.registerGridComp = function (gridPanel) {\n    this.gridPanel = gridPanel;\n  };\n\n  AlignedGridsService.prototype.init = function () {\n    this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_MOVED, this.fireColumnEvent.bind(this));\n    this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_VISIBLE, this.fireColumnEvent.bind(this));\n    this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_PINNED, this.fireColumnEvent.bind(this));\n    this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_GROUP_OPENED, this.fireColumnEvent.bind(this));\n    this.eventService.addEventListener(events_1.Events.EVENT_COLUMN_RESIZED, this.fireColumnEvent.bind(this));\n    this.eventService.addEventListener(events_1.Events.EVENT_BODY_SCROLL, this.fireScrollEvent.bind(this));\n  }; // common logic across all the fire methods\n\n\n  AlignedGridsService.prototype.fireEvent = function (callback) {\n    // if we are already consuming, then we are acting on an event from a master,\n    // so we don't cause a cyclic firing of events\n    if (this.consuming) {\n      return;\n    } // iterate through the aligned grids, and pass each aligned grid service to the callback\n\n\n    var otherGrids = this.gridOptionsWrapper.getAlignedGrids();\n\n    if (otherGrids) {\n      otherGrids.forEach(function (otherGridOptions) {\n        if (otherGridOptions.api) {\n          var alignedGridService = otherGridOptions.api.__getAlignedGridService();\n\n          callback(alignedGridService);\n        }\n      });\n    }\n  }; // common logic across all consume methods. very little common logic, however extracting\n  // guarantees consistency across the methods.\n\n\n  AlignedGridsService.prototype.onEvent = function (callback) {\n    this.consuming = true;\n    callback();\n    this.consuming = false;\n  };\n\n  AlignedGridsService.prototype.fireColumnEvent = function (event) {\n    this.fireEvent(function (alignedGridsService) {\n      alignedGridsService.onColumnEvent(event);\n    });\n  };\n\n  AlignedGridsService.prototype.fireScrollEvent = function (event) {\n    if (event.direction !== 'horizontal') {\n      return;\n    }\n\n    this.fireEvent(function (alignedGridsService) {\n      alignedGridsService.onScrollEvent(event);\n    });\n  };\n\n  AlignedGridsService.prototype.onScrollEvent = function (event) {\n    var _this = this;\n\n    this.onEvent(function () {\n      _this.gridPanel.setHorizontalScrollPosition(event.left);\n    });\n  };\n\n  AlignedGridsService.prototype.getMasterColumns = function (event) {\n    var result = [];\n\n    if (event.columns) {\n      event.columns.forEach(function (column) {\n        result.push(column);\n      });\n    } else if (event.column) {\n      result.push(event.column);\n    }\n\n    return result;\n  };\n\n  AlignedGridsService.prototype.getColumnIds = function (event) {\n    var result = [];\n\n    if (event.columns) {\n      event.columns.forEach(function (column) {\n        result.push(column.getColId());\n      });\n    } else if (event.columns) {\n      result.push(event.column.getColId());\n    }\n\n    return result;\n  };\n\n  AlignedGridsService.prototype.onColumnEvent = function (event) {\n    var _this = this;\n\n    this.onEvent(function () {\n      switch (event.type) {\n        case events_1.Events.EVENT_COLUMN_MOVED:\n        case events_1.Events.EVENT_COLUMN_VISIBLE:\n        case events_1.Events.EVENT_COLUMN_PINNED:\n        case events_1.Events.EVENT_COLUMN_RESIZED:\n          var colEvent = event;\n\n          _this.processColumnEvent(colEvent);\n\n          break;\n\n        case events_1.Events.EVENT_COLUMN_GROUP_OPENED:\n          var groupOpenedEvent = event;\n\n          _this.processGroupOpenedEvent(groupOpenedEvent);\n\n          break;\n\n        case events_1.Events.EVENT_COLUMN_PIVOT_CHANGED:\n          // we cannot support pivoting with aligned grids as the columns will be out of sync as the\n          // grids will have columns created based on the row data of the grid.\n          console.warn('ag-Grid: pivoting is not supported with aligned grids. ' + 'You can only use one of these features at a time in a grid.');\n          break;\n      }\n    });\n  };\n\n  AlignedGridsService.prototype.processGroupOpenedEvent = function (groupOpenedEvent) {\n    // likewise for column group\n    var masterColumnGroup = groupOpenedEvent.columnGroup;\n    var otherColumnGroup = undefined;\n\n    if (masterColumnGroup) {\n      var groupId = masterColumnGroup.getGroupId();\n      otherColumnGroup = this.columnController.getOriginalColumnGroup(groupId);\n    }\n\n    if (masterColumnGroup && !otherColumnGroup) {\n      return;\n    }\n\n    this.logger.log('onColumnEvent-> processing ' + groupOpenedEvent + ' expanded = ' + masterColumnGroup.isExpanded());\n    this.columnController.setColumnGroupOpened(otherColumnGroup, masterColumnGroup.isExpanded(), \"alignedGridChanged\");\n  };\n\n  AlignedGridsService.prototype.processColumnEvent = function (colEvent) {\n    var _this = this; // the column in the event is from the master grid. need to\n    // look up the equivalent from this (other) grid\n\n\n    var masterColumn = colEvent.column;\n    var otherColumn = undefined;\n\n    if (masterColumn) {\n      otherColumn = this.columnController.getPrimaryColumn(masterColumn.getColId());\n    } // if event was with respect to a master column, that is not present in this\n    // grid, then we ignore the event\n\n\n    if (masterColumn && !otherColumn) {\n      return;\n    } // in time, all the methods below should use the column ids, it's a more generic way\n    // of handling columns, and also allows for single or multi column events\n\n\n    var columnIds = this.getColumnIds(colEvent);\n    var masterColumns = this.getMasterColumns(colEvent);\n\n    switch (colEvent.type) {\n      case events_1.Events.EVENT_COLUMN_MOVED:\n        var movedEvent = colEvent;\n        this.logger.log(\"onColumnEvent-> processing \" + colEvent.type + \" toIndex = \" + movedEvent.toIndex);\n        this.columnController.moveColumns(columnIds, movedEvent.toIndex, \"alignedGridChanged\");\n        break;\n\n      case events_1.Events.EVENT_COLUMN_VISIBLE:\n        var visibleEvent = colEvent;\n        this.logger.log(\"onColumnEvent-> processing \" + colEvent.type + \" visible = \" + visibleEvent.visible);\n        this.columnController.setColumnsVisible(columnIds, visibleEvent.visible, \"alignedGridChanged\");\n        break;\n\n      case events_1.Events.EVENT_COLUMN_PINNED:\n        var pinnedEvent = colEvent;\n        this.logger.log(\"onColumnEvent-> processing \" + colEvent.type + \" pinned = \" + pinnedEvent.pinned);\n        this.columnController.setColumnsPinned(columnIds, pinnedEvent.pinned, \"alignedGridChanged\");\n        break;\n\n      case events_1.Events.EVENT_COLUMN_RESIZED:\n        var resizedEvent_1 = colEvent;\n        masterColumns.forEach(function (column) {\n          _this.logger.log(\"onColumnEvent-> processing \" + colEvent.type + \" actualWidth = \" + column.getActualWidth());\n\n          _this.columnController.setColumnWidth(column.getColId(), column.getActualWidth(), false, resizedEvent_1.finished, \"alignedGridChanged\");\n        });\n        break;\n    }\n  };\n\n  __decorate([context_3.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], AlignedGridsService.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_3.Autowired('columnController'), __metadata(\"design:type\", columnController_1.ColumnController)], AlignedGridsService.prototype, \"columnController\", void 0);\n\n  __decorate([context_3.Autowired('eventService'), __metadata(\"design:type\", eventService_1.EventService)], AlignedGridsService.prototype, \"eventService\", void 0);\n\n  __decorate([__param(0, context_2.Qualifier('loggerFactory')), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [logger_1.LoggerFactory]), __metadata(\"design:returntype\", void 0)], AlignedGridsService.prototype, \"setBeans\", null);\n\n  __decorate([context_4.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], AlignedGridsService.prototype, \"init\", null);\n\n  AlignedGridsService = __decorate([context_1.Bean('alignedGridsService')], AlignedGridsService);\n  return AlignedGridsService;\n}();\n\nexports.AlignedGridsService = AlignedGridsService;","map":null,"metadata":{},"sourceType":"script"}