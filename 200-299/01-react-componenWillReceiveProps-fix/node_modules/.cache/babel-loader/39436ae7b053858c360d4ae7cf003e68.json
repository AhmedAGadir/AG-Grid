{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils_1 = require(\"../utils\");\n\nvar column_1 = require(\"../entities/column\");\n\nvar rowNode_1 = require(\"../entities/rowNode\");\n\nvar constants_1 = require(\"../constants\");\n\nvar events_1 = require(\"../events\");\n\nvar gridCell_1 = require(\"../entities/gridCell\");\n\nvar component_1 = require(\"../widgets/component\");\n\nvar checkboxSelectionComponent_1 = require(\"./checkboxSelectionComponent\");\n\nvar rowDragComp_1 = require(\"./rowDragComp\");\n\nvar CellComp =\n/** @class */\nfunction (_super) {\n  __extends(CellComp, _super);\n\n  function CellComp(scope, beans, column, rowNode, rowComp, autoHeightCell, printLayout) {\n    var _this = _super.call(this) || this;\n\n    _this.editingCell = false; // every time we go into edit mode, or back again, this gets incremented.\n    // it's the components way of dealing with the async nature of framework components,\n    // so if a framework component takes a while to be created, we know if the object\n    // is still relevant when creating is finished. eg we could click edit / unedit 20\n    // times before the first React edit component comes back - we should discard\n    // the first 19.\n\n    _this.cellEditorVersion = 0;\n    _this.cellRendererVersion = 0;\n    _this.scope = scope;\n    _this.beans = beans;\n    _this.column = column;\n    _this.rowNode = rowNode;\n    _this.rowComp = rowComp;\n    _this.autoHeightCell = autoHeightCell;\n    _this.printLayout = printLayout;\n\n    _this.createGridCellVo();\n\n    _this.rangeSelectionEnabled = beans.enterprise && beans.gridOptionsWrapper.isEnableRangeSelection();\n    _this.cellFocused = _this.beans.focusedCellController.isCellFocused(_this.gridCell);\n    _this.firstRightPinned = _this.column.isFirstRightPinned();\n    _this.lastLeftPinned = _this.column.isLastLeftPinned();\n\n    if (_this.rangeSelectionEnabled) {\n      _this.rangeCount = _this.beans.rangeController.getCellRangeCount(_this.gridCell);\n    }\n\n    _this.getValueAndFormat();\n\n    _this.setUsingWrapper();\n\n    _this.chooseCellRenderer();\n\n    _this.setupColSpan();\n\n    _this.rowSpan = _this.column.getRowSpan(_this.rowNode);\n    return _this;\n  }\n\n  CellComp.prototype.getCreateTemplate = function () {\n    var templateParts = [];\n    var col = this.column;\n    var width = this.getCellWidth();\n    var left = this.modifyLeftForPrintLayout(col.getLeft());\n    var valueToRender = this.getInitialValueToRender();\n    var valueSanitised = utils_1._.get(this.column, 'colDef.template', null) ? valueToRender : utils_1._.escape(valueToRender);\n    this.tooltip = this.getToolTip();\n\n    var tooltipSanitised = utils_1._.escape(this.tooltip);\n\n    var colIdSanitised = utils_1._.escape(col.getId());\n\n    var wrapperStartTemplate;\n    var wrapperEndTemplate;\n    var stylesFromColDef = this.preProcessStylesFromColDef();\n    var cssClasses = this.getInitialCssClasses();\n    var stylesForRowSpanning = this.getStylesForRowSpanning();\n\n    if (this.usingWrapper) {\n      wrapperStartTemplate = '<span ref=\"eCellWrapper\" class=\"ag-cell-wrapper\"><span ref=\"eCellValue\" class=\"ag-cell-value\">';\n      wrapperEndTemplate = '</span></span>';\n    } // hey, this looks like React!!!\n\n\n    templateParts.push(\"<div\");\n    templateParts.push(\" tabindex=\\\"-1\\\"\");\n    templateParts.push(\" unselectable=\\\"on\\\"\"); // THIS IS FOR IE ONLY so text selection doesn't bubble outside of the grid\n\n    templateParts.push(\" role=\\\"gridcell\\\"\");\n    templateParts.push(\" comp-id=\\\"\" + this.getCompId() + \"\\\" \");\n    templateParts.push(\" col-id=\\\"\" + colIdSanitised + \"\\\"\");\n    templateParts.push(\" class=\\\"\" + cssClasses.join(' ') + \"\\\"\");\n    templateParts.push(utils_1._.exists(tooltipSanitised) ? \" title=\\\"\" + tooltipSanitised + \"\\\"\" : \"\");\n    templateParts.push(\" style=\\\"width: \" + width + \"px; left: \" + left + \"px; \" + stylesFromColDef + \" \" + stylesForRowSpanning + \"\\\" >\");\n    templateParts.push(wrapperStartTemplate);\n    templateParts.push(valueSanitised);\n    templateParts.push(wrapperEndTemplate);\n    templateParts.push(\"</div>\");\n    return templateParts.join('');\n  };\n\n  CellComp.prototype.getStylesForRowSpanning = function () {\n    if (this.rowSpan === 1) {\n      return '';\n    }\n\n    var singleRowHeight = this.beans.gridOptionsWrapper.getRowHeightAsNumber();\n    var totalRowHeight = singleRowHeight * this.rowSpan;\n    return \"height: \" + totalRowHeight + \"px; z-index: 1;\";\n  };\n\n  CellComp.prototype.afterAttached = function () {\n    var querySelector = \"[comp-id=\\\"\" + this.getCompId() + \"\\\"]\";\n    var eGui = this.eParentRow.querySelector(querySelector);\n    this.setGui(eGui); // all of these have dependencies on the eGui, so only do them after eGui is set\n\n    this.addDomData();\n    this.populateTemplate();\n    this.attachCellRenderer();\n    this.angular1Compile();\n    this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_CELL_FOCUSED, this.onCellFocused.bind(this));\n    this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_FLASH_CELLS, this.onFlashCells.bind(this));\n    this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_COLUMN_HOVER_CHANGED, this.onColumnHover.bind(this));\n    this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_ROW_INDEX_CHANGED, this.onRowIndexChanged.bind(this));\n    this.addDestroyableEventListener(this.rowNode, rowNode_1.RowNode.EVENT_CELL_CHANGED, this.onCellChanged.bind(this));\n    this.addDestroyableEventListener(this.column, column_1.Column.EVENT_LEFT_CHANGED, this.onLeftChanged.bind(this));\n    this.addDestroyableEventListener(this.column, column_1.Column.EVENT_WIDTH_CHANGED, this.onWidthChanged.bind(this));\n    this.addDestroyableEventListener(this.column, column_1.Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, this.onFirstRightPinnedChanged.bind(this));\n    this.addDestroyableEventListener(this.column, column_1.Column.EVENT_LAST_LEFT_PINNED_CHANGED, this.onLastLeftPinnedChanged.bind(this)); // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,\n    // then changing the width of the containers will impact left position. eg the center cols all have their\n    // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,\n    // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are\n    // in different containers so doesn't impact.\n\n    if (this.printLayout) {\n      this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onLeftChanged.bind(this));\n    } // if not doing enterprise, then range selection service would be missing\n    // so need to check before trying to use it\n\n\n    if (this.rangeSelectionEnabled) {\n      this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_RANGE_SELECTION_CHANGED, this.onRangeSelectionChanged.bind(this));\n    }\n  };\n\n  CellComp.prototype.onColumnHover = function () {\n    var isHovered = this.beans.columnHoverService.isHovered(this.column);\n\n    utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-column-hover', isHovered);\n  };\n\n  CellComp.prototype.onCellChanged = function (event) {\n    var eventImpactsThisCell = event.column === this.column;\n\n    if (eventImpactsThisCell) {\n      this.refreshCell({});\n    }\n  };\n\n  CellComp.prototype.getCellLeft = function () {\n    var mostLeftCol;\n\n    if (this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning) {\n      mostLeftCol = this.colsSpanning[this.colsSpanning.length - 1];\n    } else {\n      mostLeftCol = this.column;\n    }\n\n    return mostLeftCol.getLeft();\n  };\n\n  CellComp.prototype.getCellWidth = function () {\n    if (this.colsSpanning) {\n      var result_1 = 0;\n      this.colsSpanning.forEach(function (col) {\n        return result_1 += col.getActualWidth();\n      });\n      return result_1;\n    } else {\n      return this.column.getActualWidth();\n    }\n  };\n\n  CellComp.prototype.onFlashCells = function (event) {\n    var cellId = this.gridCell.createId();\n    var shouldFlash = event.cells[cellId];\n\n    if (shouldFlash) {\n      this.animateCell('highlight');\n    }\n  };\n\n  CellComp.prototype.setupColSpan = function () {\n    // if no col span is active, then we don't set it up, as it would be wasteful of CPU\n    if (utils_1._.missing(this.column.getColDef().colSpan)) {\n      return;\n    } // because we are col spanning, a reorder of the cols can change what cols we are spanning over\n\n\n    this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this)); // because we are spanning over multiple cols, we check for width any time any cols width changes.\n    // this is expensive - really we should be explicitly checking only the cols we are spanning over\n    // instead of every col, however it would be tricky code to track the cols we are spanning over, so\n    // because hardly anyone will be using colSpan, am favoring this easier way for more maintainable code.\n\n    this.addDestroyableEventListener(this.beans.eventService, events_1.Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this));\n    this.colsSpanning = this.getColSpanningList();\n  };\n\n  CellComp.prototype.getColSpanningList = function () {\n    var colSpan = this.column.getColSpan(this.rowNode);\n    var colsSpanning = []; // if just one col, the col span is just the column we are in\n\n    if (colSpan === 1) {\n      colsSpanning.push(this.column);\n    } else {\n      var pointer = this.column;\n      var pinned = this.column.getPinned();\n\n      for (var i = 0; i < colSpan; i++) {\n        colsSpanning.push(pointer);\n        pointer = this.beans.columnController.getDisplayedColAfter(pointer);\n\n        if (utils_1._.missing(pointer)) {\n          break;\n        } // we do not allow col spanning to span outside of pinned areas\n\n\n        if (pinned !== pointer.getPinned()) {\n          break;\n        }\n      }\n    }\n\n    return colsSpanning;\n  };\n\n  CellComp.prototype.onDisplayColumnsChanged = function () {\n    var colsSpanning = this.getColSpanningList();\n\n    if (!utils_1._.compareArrays(this.colsSpanning, colsSpanning)) {\n      this.colsSpanning = colsSpanning;\n      this.onWidthChanged();\n      this.onLeftChanged(); // left changes when doing RTL\n    }\n  };\n\n  CellComp.prototype.getInitialCssClasses = function () {\n    var cssClasses = [\"ag-cell\", \"ag-cell-not-inline-editing\"]; // if we are putting the cell into a dummy container, to work out it's height,\n    // then we don't put the height css in, as we want cell to fit height in that case.\n\n    if (!this.autoHeightCell) {\n      cssClasses.push('ag-cell-with-height');\n    }\n\n    var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\n\n    if (doingFocusCss) {\n      // otherwise the class depends on the focus state\n      cssClasses.push(this.cellFocused ? 'ag-cell-focus' : 'ag-cell-no-focus');\n    } else {\n      // if we are not doing cell selection, then ag-cell-no-focus gets put onto every cell\n      cssClasses.push('ag-cell-no-focus');\n    }\n\n    if (this.firstRightPinned) {\n      cssClasses.push('ag-cell-first-right-pinned');\n    }\n\n    if (this.lastLeftPinned) {\n      cssClasses.push('ag-cell-last-left-pinned');\n    }\n\n    if (this.beans.columnHoverService.isHovered(this.column)) {\n      cssClasses.push('ag-column-hover');\n    }\n\n    utils_1._.pushAll(cssClasses, this.preProcessClassesFromColDef());\n\n    utils_1._.pushAll(cssClasses, this.preProcessCellClassRules());\n\n    utils_1._.pushAll(cssClasses, this.getRangeClasses()); // if using the wrapper, this class goes on the wrapper instead\n\n\n    if (!this.usingWrapper) {\n      cssClasses.push('ag-cell-value');\n    }\n\n    return cssClasses;\n  };\n\n  CellComp.prototype.getInitialValueToRender = function () {\n    // if using a cellRenderer, then render the html from the cell renderer if it exists\n    if (this.usingCellRenderer) {\n      if (typeof this.cellRendererGui === 'string') {\n        return this.cellRendererGui;\n      } else {\n        return '';\n      }\n    }\n\n    var colDef = this.column.getColDef();\n\n    if (colDef.template) {\n      // template is really only used for angular 1 - as people using ng1 are used to providing templates with\n      // bindings in it. in ng2, people will hopefully want to provide components, not templates.\n      return colDef.template;\n    } else if (colDef.templateUrl) {\n      // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\n      // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\n      // not do these, but would follow a pattern that was friendly towards components, not templates.\n      var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\n\n      if (template) {\n        return template;\n      } else {\n        return '';\n      }\n    } else {\n      return this.getValueToUse();\n    }\n  };\n\n  CellComp.prototype.getRenderedRow = function () {\n    return this.rowComp;\n  };\n\n  CellComp.prototype.isSuppressNavigable = function () {\n    return this.column.isSuppressNavigable(this.rowNode);\n  };\n\n  CellComp.prototype.getCellRenderer = function () {\n    return this.cellRenderer;\n  };\n\n  CellComp.prototype.getCellEditor = function () {\n    return this.cellEditor;\n  }; // + stop editing {forceRefresh: true, suppressFlash: true}\n  // + event cellChanged {}\n  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything\n  // + rowComp: event dataChanged {animate: update, newData: !update}\n  // + rowComp: api refreshCells() {animate: true/false}\n  // + rowRenderer: api softRefreshView() {}\n\n\n  CellComp.prototype.refreshCell = function (params) {\n    if (this.editingCell) {\n      return;\n    }\n\n    var newData = params && params.newData;\n    var suppressFlash = params && params.suppressFlash || this.column.getColDef().suppressCellFlash;\n    var forceRefresh = params && params.forceRefresh;\n    var oldValue = this.value;\n    this.getValueAndFormat(); // for simple values only (not pojo's), see if the value is the same, and if it is, skip the refresh.\n    // when never allow skipping after an edit, as after editing, we need to put the GUI back to the way\n    // if was before the edit.\n\n    var valuesDifferent = !this.valuesAreEqual(oldValue, this.value);\n    var dataNeedsUpdating = forceRefresh || valuesDifferent;\n\n    if (dataNeedsUpdating) {\n      var cellRendererRefreshed = void 0; // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.\n      // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')\n      // then we are not showing a movement in the stock price, rather we are showing different stock.\n\n      if (newData || suppressFlash) {\n        cellRendererRefreshed = false;\n      } else {\n        cellRendererRefreshed = this.attemptCellRendererRefresh();\n      } // we do the replace if not doing refresh, or if refresh was unsuccessful.\n      // the refresh can be unsuccessful if we are using a framework (eg ng2 or react) and the framework\n      // wrapper has the refresh method, but the underlying component doesn't\n\n\n      if (!cellRendererRefreshed) {\n        this.replaceContentsAfterRefresh();\n      }\n\n      if (!suppressFlash) {\n        var flashCell = this.beans.gridOptionsWrapper.isEnableCellChangeFlash() || this.column.getColDef().enableCellChangeFlash;\n\n        if (flashCell) {\n          this.flashCell();\n        }\n      } // need to check rules. note, we ignore colDef classes and styles, these are assumed to be static\n\n\n      this.postProcessStylesFromColDef();\n      this.postProcessClassesFromColDef();\n    }\n\n    this.refreshToolTip(); // we do cellClassRules even if the value has not changed, so that users who have rules that\n    // look at other parts of the row (where the other part of the row might of changed) will work.\n\n    this.postProcessCellClassRules();\n  }; // user can also call this via API\n\n\n  CellComp.prototype.flashCell = function () {\n    this.animateCell('data-changed');\n  };\n\n  CellComp.prototype.animateCell = function (cssName) {\n    var fullName = 'ag-cell-' + cssName;\n    var animationFullName = 'ag-cell-' + cssName + '-animation';\n    var element = this.getGui(); // we want to highlight the cells, without any animation\n\n    utils_1._.addCssClass(element, fullName);\n\n    utils_1._.removeCssClass(element, animationFullName); // then once that is applied, we remove the highlight with animation\n\n\n    setTimeout(function () {\n      utils_1._.removeCssClass(element, fullName);\n\n      utils_1._.addCssClass(element, animationFullName);\n\n      setTimeout(function () {\n        // and then to leave things as we got them, we remove the animation\n        utils_1._.removeCssClass(element, animationFullName);\n      }, 1000);\n    }, 500);\n  };\n\n  CellComp.prototype.replaceContentsAfterRefresh = function () {\n    // otherwise we rip out the cell and replace it\n    utils_1._.removeAllChildren(this.eParentOfValue); // remove old renderer component if it exists\n\n\n    if (this.cellRenderer && this.cellRenderer.destroy) {\n      this.cellRenderer.destroy();\n    }\n\n    this.cellRenderer = null;\n    this.cellRendererGui = null; // populate\n\n    this.putDataIntoCellAfterRefresh();\n    this.angular1Compile();\n  };\n\n  CellComp.prototype.angular1Compile = function () {\n    // if angular compiling, then need to also compile the cell again (angular compiling sucks, please wait...)\n    if (this.beans.gridOptionsWrapper.isAngularCompileRows()) {\n      var eGui = this.getGui();\n      var compiledElement_1 = this.beans.$compile(eGui)(this.scope);\n      this.addDestroyFunc(function () {\n        compiledElement_1.remove();\n      });\n    }\n  };\n\n  CellComp.prototype.postProcessStylesFromColDef = function () {\n    var stylesToUse = this.processStylesFromColDef();\n\n    if (stylesToUse) {\n      utils_1._.addStylesToElement(this.getGui(), stylesToUse);\n    }\n  };\n\n  CellComp.prototype.preProcessStylesFromColDef = function () {\n    var stylesToUse = this.processStylesFromColDef();\n    return utils_1._.cssStyleObjectToMarkup(stylesToUse);\n  };\n\n  CellComp.prototype.processStylesFromColDef = function () {\n    var colDef = this.column.getColDef();\n\n    if (colDef.cellStyle) {\n      var cssToUse = void 0;\n\n      if (typeof colDef.cellStyle === 'function') {\n        var cellStyleParams = {\n          value: this.value,\n          data: this.rowNode.data,\n          node: this.rowNode,\n          colDef: colDef,\n          column: this.column,\n          $scope: this.scope,\n          context: this.beans.gridOptionsWrapper.getContext(),\n          api: this.beans.gridOptionsWrapper.getApi()\n        };\n        var cellStyleFunc = colDef.cellStyle;\n        cssToUse = cellStyleFunc(cellStyleParams);\n      } else {\n        cssToUse = colDef.cellStyle;\n      }\n\n      return cssToUse;\n    }\n  };\n\n  CellComp.prototype.postProcessClassesFromColDef = function () {\n    var _this = this;\n\n    this.processClassesFromColDef(function (className) {\n      return utils_1._.addCssClass(_this.getGui(), className);\n    });\n  };\n\n  CellComp.prototype.preProcessClassesFromColDef = function () {\n    var res = [];\n    this.processClassesFromColDef(function (className) {\n      return res.push(className);\n    });\n    return res;\n  };\n\n  CellComp.prototype.processClassesFromColDef = function (onApplicableClass) {\n    this.beans.stylingService.processStaticCellClasses(this.column.getColDef(), {\n      value: this.value,\n      data: this.rowNode.data,\n      node: this.rowNode,\n      colDef: this.column.getColDef(),\n      rowIndex: this.rowNode.rowIndex,\n      $scope: this.scope,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      context: this.beans.gridOptionsWrapper.getContext()\n    }, onApplicableClass);\n  };\n\n  CellComp.prototype.putDataIntoCellAfterRefresh = function () {\n    // template gets preference, then cellRenderer, then do it ourselves\n    var colDef = this.column.getColDef();\n\n    if (colDef.template) {\n      // template is really only used for angular 1 - as people using ng1 are used to providing templates with\n      // bindings in it. in ng2, people will hopefully want to provide components, not templates.\n      this.eParentOfValue.innerHTML = colDef.template;\n    } else if (colDef.templateUrl) {\n      // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\n      // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\n      // not do these, but would follow a pattern that was friendly towards components, not templates.\n      var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\n\n      if (template) {\n        this.eParentOfValue.innerHTML = template;\n      } // use cell renderer if it exists\n\n    } else if (this.usingCellRenderer) {\n      this.attachCellRenderer();\n    } else {\n      var valueToUse = this.getValueToUse();\n\n      if (valueToUse !== null && valueToUse !== undefined) {\n        this.eParentOfValue.innerText = valueToUse;\n      }\n    }\n  };\n\n  CellComp.prototype.attemptCellRendererRefresh = function () {\n    if (utils_1._.missing(this.cellRenderer) || utils_1._.missing(this.cellRenderer.refresh)) {\n      return false;\n    } // if the cell renderer has a refresh method, we call this instead of doing a refresh\n    // note: should pass in params here instead of value?? so that client has formattedValue\n\n\n    var params = this.createCellRendererParams();\n    var result = this.cellRenderer.refresh(params); // NOTE on undefined: previous version of the cellRenderer.refresh() interface\n    // returned nothing, if the method existed, we assumed it refreshed. so for\n    // backwards compatibility, we assume if method exists and returns nothing,\n    // that it was successful.\n\n    return result === true || result === undefined;\n  };\n\n  CellComp.prototype.refreshToolTip = function () {\n    var newTooltip = this.getToolTip();\n\n    if (this.tooltip !== newTooltip) {\n      this.tooltip = newTooltip;\n\n      if (utils_1._.exists(newTooltip)) {\n        var tooltipSanitised = utils_1._.escape(this.tooltip);\n\n        this.eParentOfValue.setAttribute('title', tooltipSanitised);\n      } else {\n        this.eParentOfValue.removeAttribute('title');\n      }\n    }\n  };\n\n  CellComp.prototype.valuesAreEqual = function (val1, val2) {\n    // if the user provided an equals method, use that, otherwise do simple comparison\n    var colDef = this.column.getColDef();\n    var equalsMethod = colDef ? colDef.equals : null;\n\n    if (equalsMethod) {\n      return equalsMethod(val1, val2);\n    } else {\n      return val1 === val2;\n    }\n  };\n\n  CellComp.prototype.getToolTip = function () {\n    var colDef = this.column.getColDef();\n    var data = this.rowNode.data;\n\n    if (colDef.tooltipField && utils_1._.exists(data)) {\n      return utils_1._.getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());\n    } else if (colDef.tooltip) {\n      return colDef.tooltip({\n        value: this.value,\n        valueFormatted: this.valueFormatted,\n        data: this.rowNode.data,\n        node: this.rowNode,\n        colDef: this.column.getColDef(),\n        api: this.beans.gridOptionsWrapper.getApi(),\n        $scope: this.scope,\n        context: this.beans.gridOptionsWrapper.getContext(),\n        rowIndex: this.gridCell.rowIndex\n      });\n    } else {\n      return null;\n    }\n  };\n\n  CellComp.prototype.processCellClassRules = function (onApplicableClass, onNotApplicableClass) {\n    this.beans.stylingService.processClassRules(this.column.getColDef().cellClassRules, {\n      value: this.value,\n      data: this.rowNode.data,\n      node: this.rowNode,\n      colDef: this.column.getColDef(),\n      rowIndex: this.gridCell.rowIndex,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      $scope: this.scope,\n      context: this.beans.gridOptionsWrapper.getContext()\n    }, onApplicableClass, onNotApplicableClass);\n  };\n\n  CellComp.prototype.postProcessCellClassRules = function () {\n    var _this = this;\n\n    this.processCellClassRules(function (className) {\n      utils_1._.addCssClass(_this.getGui(), className);\n    }, function (className) {\n      utils_1._.removeCssClass(_this.getGui(), className);\n    });\n  };\n\n  CellComp.prototype.preProcessCellClassRules = function () {\n    var res = [];\n    this.processCellClassRules(function (className) {\n      res.push(className);\n    }, function (className) {// not catered for, if creating, no need\n      // to remove class as it was never there\n    });\n    return res;\n  }; // a wrapper is used when we are putting a selection checkbox in the cell with the value\n\n\n  CellComp.prototype.setUsingWrapper = function () {\n    var colDef = this.column.getColDef(); // never allow selection or dragging on pinned rows\n\n    if (this.rowNode.rowPinned) {\n      this.usingWrapper = false;\n      this.includeSelectionComponent = false;\n      this.includeRowDraggingComponent = false;\n      return;\n    }\n\n    var cbSelectionIsFunc = typeof colDef.checkboxSelection === 'function';\n    var rowDraggableIsFunc = typeof colDef.rowDrag === 'function';\n    this.includeSelectionComponent = cbSelectionIsFunc || colDef.checkboxSelection === true;\n    this.includeRowDraggingComponent = rowDraggableIsFunc || colDef.rowDrag === true;\n    this.usingWrapper = this.includeRowDraggingComponent || this.includeSelectionComponent;\n  };\n\n  CellComp.prototype.chooseCellRenderer = function () {\n    // template gets preference, then cellRenderer, then do it ourselves\n    var colDef = this.column.getColDef(); // templates are for ng1, ideally we wouldn't have these, they are ng1 support\n    // inside the core which is bad\n\n    if (colDef.template || colDef.templateUrl) {\n      this.usingCellRenderer = false;\n      return;\n    }\n\n    var params = this.createCellRendererParams();\n    var cellRenderer = this.beans.componentResolver.getComponentToUse(colDef, 'cellRenderer', params, null);\n    var pinnedRowCellRenderer = this.beans.componentResolver.getComponentToUse(colDef, 'pinnedRowCellRenderer', params, null);\n\n    if (pinnedRowCellRenderer && this.rowNode.rowPinned) {\n      this.cellRendererType = 'pinnedRowCellRenderer';\n      this.usingCellRenderer = true;\n    } else if (cellRenderer) {\n      this.cellRendererType = 'cellRenderer';\n      this.usingCellRenderer = true;\n    } else {\n      this.usingCellRenderer = false;\n    }\n  };\n\n  CellComp.prototype.createCellRendererInstance = function () {\n    var params = this.createCellRendererParams();\n    this.cellRendererVersion++;\n    var callback = this.afterCellRendererCreated.bind(this, this.cellRendererVersion);\n    this.beans.componentResolver.createAgGridComponent(this.column.getColDef(), params, this.cellRendererType, params, null).then(callback);\n  };\n\n  CellComp.prototype.afterCellRendererCreated = function (cellRendererVersion, cellRenderer) {\n    // see if daemon\n    if (!this.isAlive() || cellRendererVersion !== this.cellRendererVersion) {\n      if (cellRenderer.destroy) {\n        cellRenderer.destroy();\n      }\n\n      return;\n    }\n\n    this.cellRenderer = cellRenderer;\n    this.cellRendererGui = this.cellRenderer.getGui();\n\n    if (utils_1._.missing(this.cellRendererGui)) {\n      return;\n    } // if async components, then it's possible the user started editing since\n    // this call was made\n\n\n    if (!this.editingCell) {\n      this.eParentOfValue.appendChild(this.cellRendererGui);\n    }\n  };\n\n  CellComp.prototype.attachCellRenderer = function () {\n    if (!this.usingCellRenderer) {\n      return;\n    }\n\n    this.createCellRendererInstance();\n  };\n\n  CellComp.prototype.createCellRendererParams = function () {\n    var _this = this;\n\n    var params = {\n      value: this.value,\n      valueFormatted: this.valueFormatted,\n      getValue: this.getValue.bind(this),\n      setValue: function setValue(value) {\n        _this.beans.valueService.setValue(_this.rowNode, _this.column, value);\n      },\n      formatValue: this.formatValue.bind(this),\n      data: this.rowNode.data,\n      node: this.rowNode,\n      colDef: this.column.getColDef(),\n      column: this.column,\n      $scope: this.scope,\n      rowIndex: this.gridCell.rowIndex,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext(),\n      refreshCell: this.refreshCell.bind(this),\n      eGridCell: this.getGui(),\n      eParentOfValue: this.eParentOfValue,\n      // these bits are not documented anywhere, so we could drop them?\n      // it was in the olden days to allow user to register for when rendered\n      // row was removed (the row comp was removed), however now that the user\n      // can provide components for cells, the destroy method gets call when this\n      // happens so no longer need to fire event.\n      addRowCompListener: this.rowComp ? this.rowComp.addEventListener.bind(this.rowComp) : null,\n      addRenderedRowListener: function addRenderedRowListener(eventType, listener) {\n        console.warn('ag-Grid: since ag-Grid .v11, params.addRenderedRowListener() is now params.addRowCompListener()');\n\n        if (_this.rowComp) {\n          _this.rowComp.addEventListener(eventType, listener);\n        }\n      }\n    };\n    return params;\n  };\n\n  CellComp.prototype.formatValue = function (value) {\n    var valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, value);\n    var valueFormattedExists = valueFormatted !== null && valueFormatted !== undefined;\n    return valueFormattedExists ? valueFormatted : value;\n  };\n\n  CellComp.prototype.getValueToUse = function () {\n    var valueFormattedExists = this.valueFormatted !== null && this.valueFormatted !== undefined;\n    return valueFormattedExists ? this.valueFormatted : this.value;\n  };\n\n  CellComp.prototype.getValueAndFormat = function () {\n    this.value = this.getValue();\n    this.valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, this.value);\n  };\n\n  CellComp.prototype.getValue = function () {\n    // if we don't check this, then the grid will render leaf groups as open even if we are not\n    // allowing the user to open leaf groups. confused? remember for pivot mode we don't allow\n    // opening leaf groups, so we have to force leafGroups to be closed in case the user expanded\n    // them via the API, or user user expanded them in the UI before turning on pivot mode\n    var lockedClosedGroup = this.rowNode.leafGroup && this.beans.columnController.isPivotMode();\n    var isOpenGroup = this.rowNode.group && this.rowNode.expanded && !this.rowNode.footer && !lockedClosedGroup;\n\n    if (isOpenGroup && this.beans.gridOptionsWrapper.isGroupIncludeFooter()) {\n      // if doing grouping and footers, we don't want to include the agg value\n      // in the header when the group is open\n      return this.beans.valueService.getValue(this.column, this.rowNode, false, true);\n    } else {\n      return this.beans.valueService.getValue(this.column, this.rowNode);\n    }\n  };\n\n  CellComp.prototype.onMouseEvent = function (eventName, mouseEvent) {\n    if (utils_1._.isStopPropagationForAgGrid(mouseEvent)) {\n      return;\n    }\n\n    switch (eventName) {\n      case 'click':\n        this.onCellClicked(mouseEvent);\n        break;\n\n      case 'mousedown':\n        this.onMouseDown(mouseEvent);\n        break;\n\n      case 'dblclick':\n        this.onCellDoubleClicked(mouseEvent);\n        break;\n\n      case 'mouseout':\n        this.onMouseOut(mouseEvent);\n        break;\n\n      case 'mouseover':\n        this.onMouseOver(mouseEvent);\n        break;\n    }\n  };\n\n  CellComp.prototype.dispatchCellContextMenuEvent = function (event) {\n    var colDef = this.column.getColDef();\n    var cellContextMenuEvent = this.createEvent(event, events_1.Events.EVENT_CELL_CONTEXT_MENU);\n    this.beans.eventService.dispatchEvent(cellContextMenuEvent);\n\n    if (colDef.onCellContextMenu) {\n      // to make the callback async, do in a timeout\n      setTimeout(function () {\n        return colDef.onCellContextMenu(cellContextMenuEvent);\n      }, 0);\n    }\n  };\n\n  CellComp.prototype.createEvent = function (domEvent, eventType) {\n    var event = {\n      node: this.rowNode,\n      data: this.rowNode.data,\n      value: this.value,\n      column: this.column,\n      colDef: this.column.getColDef(),\n      context: this.beans.gridOptionsWrapper.getContext(),\n      api: this.beans.gridApi,\n      columnApi: this.beans.columnApi,\n      rowPinned: this.rowNode.rowPinned,\n      event: domEvent,\n      type: eventType,\n      rowIndex: this.rowNode.rowIndex\n    }; // because we are hacking in $scope for angular 1, we have to de-reference\n\n    if (this.scope) {\n      event.$scope = this.scope;\n    }\n\n    return event;\n  };\n\n  CellComp.prototype.onMouseOut = function (mouseEvent) {\n    var cellMouseOutEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_OUT);\n    this.beans.eventService.dispatchEvent(cellMouseOutEvent);\n    this.beans.columnHoverService.clearMouseOver();\n  };\n\n  CellComp.prototype.onMouseOver = function (mouseEvent) {\n    var cellMouseOverEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_OVER);\n    this.beans.eventService.dispatchEvent(cellMouseOverEvent);\n    this.beans.columnHoverService.setMouseOver([this.column]);\n  };\n\n  CellComp.prototype.onCellDoubleClicked = function (mouseEvent) {\n    var colDef = this.column.getColDef(); // always dispatch event to eventService\n\n    var cellDoubleClickedEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_DOUBLE_CLICKED);\n    this.beans.eventService.dispatchEvent(cellDoubleClickedEvent); // check if colDef also wants to handle event\n\n    if (typeof colDef.onCellDoubleClicked === 'function') {\n      // to make the callback async, do in a timeout\n      setTimeout(function () {\n        return colDef.onCellDoubleClicked(cellDoubleClickedEvent);\n      }, 0);\n    }\n\n    var editOnDoubleClick = !this.beans.gridOptionsWrapper.isSingleClickEdit() && !this.beans.gridOptionsWrapper.isSuppressClickEdit();\n\n    if (editOnDoubleClick) {\n      this.startRowOrCellEdit();\n    }\n  }; // called by rowRenderer when user navigates via tab key\n\n\n  CellComp.prototype.startRowOrCellEdit = function (keyPress, charPress) {\n    if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n      this.rowComp.startRowEditing(keyPress, charPress, this);\n    } else {\n      this.startEditingIfEnabled(keyPress, charPress, true);\n    }\n  };\n\n  CellComp.prototype.isCellEditable = function () {\n    return this.column.isCellEditable(this.rowNode);\n  }; // either called internally if single cell editing, or called by rowRenderer if row editing\n\n\n  CellComp.prototype.startEditingIfEnabled = function (keyPress, charPress, cellStartedEdit) {\n    if (keyPress === void 0) {\n      keyPress = null;\n    }\n\n    if (charPress === void 0) {\n      charPress = null;\n    }\n\n    if (cellStartedEdit === void 0) {\n      cellStartedEdit = false;\n    } // don't do it if not editable\n\n\n    if (!this.isCellEditable()) {\n      return;\n    } // don't do it if already editing\n\n\n    if (this.editingCell) {\n      return;\n    }\n\n    this.editingCell = true;\n    this.cellEditorVersion++;\n    var callback = this.afterCellEditorCreated.bind(this, this.cellEditorVersion);\n    var params = this.createCellEditorParams(keyPress, charPress, cellStartedEdit);\n    this.beans.cellEditorFactory.createCellEditor(this.column.getColDef(), params).then(callback); // if we don't do this, and editor component is async, then there will be a period\n    // when the component isn't present and keyboard navigation won't work - so example\n    // of user hitting tab quickly (more quickly than renderers getting created) won't work\n\n    var cellEditorAsync = utils_1._.missing(this.cellEditor);\n\n    if (cellEditorAsync && cellStartedEdit) {\n      this.focusCell(true);\n    }\n  };\n\n  CellComp.prototype.afterCellEditorCreated = function (cellEditorVersion, cellEditor) {\n    // if editingCell=false, means user cancelled the editor before component was ready.\n    // if versionMismatch, then user cancelled the edit, then started the edit again, and this\n    //   is the first editor which is now stale.\n    var versionMismatch = cellEditorVersion !== this.cellEditorVersion;\n\n    if (versionMismatch || !this.editingCell) {\n      if (cellEditor.destroy) {\n        cellEditor.destroy();\n      }\n\n      return;\n    }\n\n    if (cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart()) {\n      if (cellEditor.destroy) {\n        cellEditor.destroy();\n      }\n\n      this.editingCell = false;\n      return;\n    }\n\n    if (!cellEditor.getGui) {\n      console.warn(\"ag-Grid: cellEditor for column \" + this.column.getId() + \" is missing getGui() method\"); // no getGui, for React guys, see if they attached a react component directly\n\n      if (cellEditor.render) {\n        console.warn(\"ag-Grid: we found 'render' on the component, are you trying to set a React renderer but added it as colDef.cellEditor instead of colDef.cellEditorFmk?\");\n      }\n\n      if (cellEditor.destroy) {\n        cellEditor.destroy();\n      }\n\n      this.editingCell = false;\n      return;\n    }\n\n    this.cellEditor = cellEditor;\n    this.cellEditorInPopup = cellEditor.isPopup && cellEditor.isPopup();\n    this.setInlineEditingClass();\n\n    if (this.cellEditorInPopup) {\n      this.addPopupCellEditor();\n    } else {\n      this.addInCellEditor();\n    }\n\n    if (cellEditor.afterGuiAttached) {\n      cellEditor.afterGuiAttached();\n    }\n\n    var event = this.createEvent(null, events_1.Events.EVENT_CELL_EDITING_STARTED);\n    this.beans.eventService.dispatchEvent(event);\n  };\n\n  CellComp.prototype.addInCellEditor = function () {\n    utils_1._.removeAllChildren(this.getGui());\n\n    this.getGui().appendChild(this.cellEditor.getGui());\n    this.angular1Compile();\n  };\n\n  CellComp.prototype.addPopupCellEditor = function () {\n    var _this = this;\n\n    var ePopupGui = this.cellEditor.getGui();\n    this.hideEditorPopup = this.beans.popupService.addAsModalPopup(ePopupGui, true, // callback for when popup disappears\n    function () {\n      _this.onPopupEditorClosed();\n    });\n    this.beans.popupService.positionPopupOverComponent({\n      column: this.column,\n      rowNode: this.rowNode,\n      type: 'popupCellEditor',\n      eventSource: this.getGui(),\n      ePopup: ePopupGui,\n      keepWithinBounds: true\n    });\n    this.angular1Compile();\n  };\n\n  CellComp.prototype.onPopupEditorClosed = function () {\n    // we only call stopEditing if we are editing, as\n    // it's possible the popup called 'stop editing'\n    // before this, eg if 'enter key' was pressed on\n    // the editor.\n    if (this.editingCell) {\n      // note: this only happens when use clicks outside of the grid. if use clicks on another\n      // cell, then the editing will have already stopped on this cell\n      this.stopRowOrCellEdit(); // we only focus cell again if this cell is still focused. it is possible\n      // it is not focused if the user cancelled the edit by clicking on another\n      // cell outside of this one\n\n      if (this.beans.focusedCellController.isCellFocused(this.gridCell)) {\n        this.focusCell(true);\n      }\n    }\n  }; // if we are editing inline, then we don't have the padding in the cell (set in the themes)\n  // to allow the text editor full access to the entire cell\n\n\n  CellComp.prototype.setInlineEditingClass = function () {\n    // ag-cell-inline-editing - appears when user is inline editing\n    // ag-cell-not-inline-editing - appears when user is no inline editing\n    // ag-cell-popup-editing - appears when user is editing cell in popup (appears on the cell, not on the popup)\n    // note: one of {ag-cell-inline-editing, ag-cell-not-inline-editing} is always present, they toggle.\n    //       however {ag-cell-popup-editing} shows when popup, so you have both {ag-cell-popup-editing}\n    //       and {ag-cell-not-inline-editing} showing at the same time.\n    var editingInline = this.editingCell && !this.cellEditorInPopup;\n    var popupEditorShowing = this.editingCell && this.cellEditorInPopup;\n\n    utils_1._.addOrRemoveCssClass(this.getGui(), \"ag-cell-inline-editing\", editingInline);\n\n    utils_1._.addOrRemoveCssClass(this.getGui(), \"ag-cell-not-inline-editing\", !editingInline);\n\n    utils_1._.addOrRemoveCssClass(this.getGui(), \"ag-cell-popup-editing\", popupEditorShowing);\n\n    utils_1._.addOrRemoveCssClass(this.getGui().parentNode, \"ag-row-inline-editing\", editingInline);\n\n    utils_1._.addOrRemoveCssClass(this.getGui().parentNode, \"ag-row-not-inline-editing\", !editingInline);\n  };\n\n  CellComp.prototype.createCellEditorParams = function (keyPress, charPress, cellStartedEdit) {\n    var params = {\n      value: this.getValue(),\n      keyPress: keyPress,\n      charPress: charPress,\n      column: this.column,\n      rowIndex: this.gridCell.rowIndex,\n      node: this.rowNode,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      cellStartedEdit: cellStartedEdit,\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext(),\n      $scope: this.scope,\n      onKeyDown: this.onKeyDown.bind(this),\n      stopEditing: this.stopEditingAndFocus.bind(this),\n      eGridCell: this.getGui(),\n      parseValue: this.parseValue.bind(this),\n      formatValue: this.formatValue.bind(this)\n    };\n    return params;\n  }; // cell editors call this, when they want to stop for reasons other\n  // than what we pick up on. eg selecting from a dropdown ends editing.\n\n\n  CellComp.prototype.stopEditingAndFocus = function (suppressNavigateAfterEdit) {\n    if (suppressNavigateAfterEdit === void 0) {\n      suppressNavigateAfterEdit = false;\n    }\n\n    this.stopRowOrCellEdit();\n    this.focusCell(true);\n\n    if (!suppressNavigateAfterEdit) {\n      this.navigateAfterEdit();\n    }\n  };\n\n  CellComp.prototype.parseValue = function (newValue) {\n    var params = {\n      node: this.rowNode,\n      data: this.rowNode.data,\n      oldValue: this.value,\n      newValue: newValue,\n      colDef: this.column.getColDef(),\n      column: this.column,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext()\n    };\n    var valueParser = this.column.getColDef().valueParser;\n    return utils_1._.exists(valueParser) ? this.beans.expressionService.evaluate(valueParser, params) : newValue;\n  };\n\n  CellComp.prototype.focusCell = function (forceBrowserFocus) {\n    if (forceBrowserFocus === void 0) {\n      forceBrowserFocus = false;\n    }\n\n    this.beans.focusedCellController.setFocusedCell(this.gridCell.rowIndex, this.column, this.rowNode.rowPinned, forceBrowserFocus);\n  };\n\n  CellComp.prototype.setFocusInOnEditor = function () {\n    if (this.editingCell) {\n      if (this.cellEditor && this.cellEditor.focusIn) {\n        // if the editor is present, then we just focus it\n        this.cellEditor.focusIn();\n      } else {\n        // if the editor is not present, it means async cell editor (eg React fibre)\n        // and we are trying to set focus before the cell editor is present, so we\n        // focus the cell instead\n        this.focusCell(true);\n      }\n    }\n  };\n\n  CellComp.prototype.isEditing = function () {\n    return this.editingCell;\n  };\n\n  CellComp.prototype.onKeyDown = function (event) {\n    var key = event.which || event.keyCode; // give user a chance to cancel event processing\n\n    if (this.doesUserWantToCancelKeyboardEvent(event)) {\n      return;\n    }\n\n    switch (key) {\n      case constants_1.Constants.KEY_ENTER:\n        this.onEnterKeyDown();\n        break;\n\n      case constants_1.Constants.KEY_F2:\n        this.onF2KeyDown();\n        break;\n\n      case constants_1.Constants.KEY_ESCAPE:\n        this.onEscapeKeyDown();\n        break;\n\n      case constants_1.Constants.KEY_TAB:\n        this.onTabKeyDown(event);\n        break;\n\n      case constants_1.Constants.KEY_BACKSPACE:\n      case constants_1.Constants.KEY_DELETE:\n        this.onBackspaceOrDeleteKeyPressed(key);\n        break;\n\n      case constants_1.Constants.KEY_DOWN:\n      case constants_1.Constants.KEY_UP:\n      case constants_1.Constants.KEY_RIGHT:\n      case constants_1.Constants.KEY_LEFT:\n        this.onNavigationKeyPressed(event, key);\n        break;\n    }\n  };\n\n  CellComp.prototype.doesUserWantToCancelKeyboardEvent = function (event) {\n    var callback = this.column.getColDef().suppressKeyboardEvent;\n\n    if (utils_1._.missing(callback)) {\n      return false;\n    } else {\n      // if editing is null or undefined, this sets it to false\n      var params = {\n        event: event,\n        editing: this.editingCell,\n        column: this.column,\n        api: this.beans.gridOptionsWrapper.getApi(),\n        node: this.rowNode,\n        data: this.rowNode.data,\n        colDef: this.column.getColDef(),\n        context: this.beans.gridOptionsWrapper.getContext(),\n        columnApi: this.beans.gridOptionsWrapper.getColumnApi()\n      };\n      return callback(params);\n    }\n  };\n\n  CellComp.prototype.setFocusOutOnEditor = function () {\n    if (this.editingCell && this.cellEditor && this.cellEditor.focusOut) {\n      this.cellEditor.focusOut();\n    }\n  };\n\n  CellComp.prototype.onNavigationKeyPressed = function (event, key) {\n    if (this.editingCell) {\n      this.stopRowOrCellEdit();\n    }\n\n    if (event.shiftKey && this.rangeSelectionEnabled) {\n      this.onShiftRangeSelect(key);\n    } else {\n      this.beans.rowRenderer.navigateToNextCell(event, key, this.gridCell, true);\n    } // if we don't prevent default, the grid will scroll with the navigation keys\n\n\n    event.preventDefault();\n  };\n\n  CellComp.prototype.onShiftRangeSelect = function (key) {\n    var success = this.beans.rangeController.extendRangeInDirection(this.gridCell, key);\n\n    if (!success) {\n      return;\n    }\n\n    var ranges = this.beans.rangeController.getCellRanges(); // this should never happen, as extendRangeFromCell should always have one range after getting called\n\n    if (utils_1._.missing(ranges) || ranges.length !== 1) {\n      return;\n    }\n\n    var endCell = ranges[0].end;\n    this.beans.rowRenderer.ensureCellVisible(endCell);\n  };\n\n  CellComp.prototype.onTabKeyDown = function (event) {\n    if (this.beans.gridOptionsWrapper.isSuppressTabbing()) {\n      return;\n    }\n\n    this.beans.rowRenderer.onTabKeyDown(this, event);\n  };\n\n  CellComp.prototype.onBackspaceOrDeleteKeyPressed = function (key) {\n    if (!this.editingCell) {\n      this.startRowOrCellEdit(key);\n    }\n  };\n\n  CellComp.prototype.onEnterKeyDown = function () {\n    if (this.editingCell || this.rowComp.isEditing()) {\n      this.stopEditingAndFocus();\n    } else {\n      if (this.beans.gridOptionsWrapper.isEnterMovesDown()) {\n        this.beans.rowRenderer.navigateToNextCell(null, constants_1.Constants.KEY_DOWN, this.gridCell, false);\n      } else {\n        this.startRowOrCellEdit(constants_1.Constants.KEY_ENTER);\n      }\n    }\n  };\n\n  CellComp.prototype.navigateAfterEdit = function () {\n    var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\n\n    if (fullRowEdit) {\n      return;\n    }\n\n    var enterMovesDownAfterEdit = this.beans.gridOptionsWrapper.isEnterMovesDownAfterEdit();\n\n    if (enterMovesDownAfterEdit) {\n      this.beans.rowRenderer.navigateToNextCell(null, constants_1.Constants.KEY_DOWN, this.gridCell, false);\n    }\n  };\n\n  CellComp.prototype.onF2KeyDown = function () {\n    if (!this.editingCell) {\n      this.startRowOrCellEdit(constants_1.Constants.KEY_F2);\n    }\n  };\n\n  CellComp.prototype.onEscapeKeyDown = function () {\n    if (this.editingCell) {\n      this.stopRowOrCellEdit(true);\n      this.focusCell(true);\n    }\n  };\n\n  CellComp.prototype.onKeyPress = function (event) {\n    // check this, in case focus is on a (for example) a text field inside the cell,\n    // in which cse we should not be listening for these key pressed\n    var eventTarget = utils_1._.getTarget(event);\n\n    var eventOnChildComponent = eventTarget !== this.getGui();\n\n    if (eventOnChildComponent) {\n      return;\n    }\n\n    if (!this.editingCell) {\n      var pressedChar = String.fromCharCode(event.charCode);\n\n      if (pressedChar === ' ') {\n        this.onSpaceKeyPressed(event);\n      } else {\n        if (utils_1._.isEventFromPrintableCharacter(event)) {\n          this.startRowOrCellEdit(null, pressedChar); // if we don't prevent default, then the keypress also gets applied to the text field\n          // (at least when doing the default editor), but we need to allow the editor to decide\n          // what it wants to do. we only do this IF editing was started - otherwise it messes\n          // up when the use is not doing editing, but using rendering with text fields in cellRenderer\n          // (as it would block the the user from typing into text fields).\n\n          event.preventDefault();\n        }\n      }\n    }\n  };\n\n  CellComp.prototype.onSpaceKeyPressed = function (event) {\n    if (!this.editingCell && this.beans.gridOptionsWrapper.isRowSelection()) {\n      var selected = this.rowNode.isSelected();\n      this.rowNode.setSelected(!selected);\n    } // prevent default as space key, by default, moves browser scroll down\n\n\n    event.preventDefault();\n  };\n\n  CellComp.prototype.onMouseDown = function (mouseEvent) {\n    // we only need to pass true to focusCell in when the browser is IE\n    // and we are trying to focus a cell (has ag-cell class), otherwise\n    // we pass false, as we don't want the cell to focus also get the browser\n    // focus. if we did, then the cellRenderer could have a text field in it,\n    // for example, and as the user clicks on the text field, the text field,\n    // the focus doesn't get to the text field, instead to goes to the div\n    // behind, making it impossible to select the text field.\n    var forceBrowserFocus = false;\n\n    if (utils_1._.isBrowserIE()) {\n      var target = mouseEvent.target;\n\n      if (target.classList.contains('ag-cell')) {\n        forceBrowserFocus = true;\n      }\n    }\n\n    this.focusCell(forceBrowserFocus); // if it's a right click, then if the cell is already in range,\n    // don't change the range, however if the cell is not in a range,\n    // we set a new range\n\n    var leftMouseButtonClick = utils_1._.isLeftClick(mouseEvent);\n\n    if (leftMouseButtonClick && this.beans.rangeController) {\n      var thisCell = this.gridCell;\n\n      if (mouseEvent.shiftKey) {\n        this.beans.rangeController.extendRangeToCell(thisCell);\n      } else {\n        var ctrlKeyPressed = mouseEvent.ctrlKey || mouseEvent.metaKey;\n        this.beans.rangeController.setRangeToCell(thisCell, ctrlKeyPressed);\n      }\n    }\n\n    var cellMouseDownEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_MOUSE_DOWN);\n    this.beans.eventService.dispatchEvent(cellMouseDownEvent);\n  }; // returns true if on iPad and this is second 'click' event in 200ms\n\n\n  CellComp.prototype.isDoubleClickOnIPad = function () {\n    if (!utils_1._.isUserAgentIPad()) {\n      return false;\n    }\n\n    var nowMillis = new Date().getTime();\n    var res = nowMillis - this.lastIPadMouseClickEvent < 200;\n    this.lastIPadMouseClickEvent = nowMillis;\n    return res;\n  };\n\n  CellComp.prototype.onCellClicked = function (mouseEvent) {\n    // iPad doesn't have double click - so we need to mimic it do enable editing for\n    // iPad.\n    if (this.isDoubleClickOnIPad()) {\n      this.onCellDoubleClicked(mouseEvent);\n      mouseEvent.preventDefault(); // if we don't do this, then ipad zooms in\n\n      return;\n    }\n\n    var cellClickedEvent = this.createEvent(mouseEvent, events_1.Events.EVENT_CELL_CLICKED);\n    this.beans.eventService.dispatchEvent(cellClickedEvent);\n    var colDef = this.column.getColDef();\n\n    if (colDef.onCellClicked) {\n      // to make callback async, do in a timeout\n      setTimeout(function () {\n        return colDef.onCellClicked(cellClickedEvent);\n      }, 0);\n    }\n\n    var editOnSingleClick = (this.beans.gridOptionsWrapper.isSingleClickEdit() || colDef.singleClickEdit) && !this.beans.gridOptionsWrapper.isSuppressClickEdit();\n\n    if (editOnSingleClick) {\n      this.startRowOrCellEdit();\n    }\n\n    this.doIeFocusHack();\n  }; // https://ag-grid.com/forum/showthread.php?tid=4362\n  // when in IE or Edge, when you are editing a cell, then click on another cell,\n  // the other cell doesn't keep focus, so navigation keys, type to start edit etc\n  // don't work. appears that when you update the dom in IE it looses focus\n\n\n  CellComp.prototype.doIeFocusHack = function () {\n    if (utils_1._.isBrowserIE() || utils_1._.isBrowserEdge()) {\n      if (utils_1._.missing(document.activeElement) || document.activeElement === document.body) {\n        // console.log('missing focus');\n        this.getGui().focus();\n      }\n    }\n  };\n\n  CellComp.prototype.createGridCellVo = function () {\n    var gridCellDef = {\n      rowIndex: this.rowNode.rowIndex,\n      floating: this.rowNode.rowPinned,\n      column: this.column\n    };\n    this.gridCell = new gridCell_1.GridCell(gridCellDef);\n  };\n\n  CellComp.prototype.getGridCell = function () {\n    return this.gridCell;\n  };\n\n  CellComp.prototype.getParentRow = function () {\n    return this.eParentRow;\n  };\n\n  CellComp.prototype.setParentRow = function (eParentRow) {\n    this.eParentRow = eParentRow;\n  };\n\n  CellComp.prototype.getColumn = function () {\n    return this.column;\n  };\n\n  CellComp.prototype.detach = function () {\n    this.eParentRow.removeChild(this.getGui());\n  }; // if the row is also getting destroyed, then we don't need to remove from dom,\n  // as the row will also get removed, so no need to take out the cells from the row\n  // if the row is going (removing is an expensive operation, so only need to remove\n  // the top part)\n\n\n  CellComp.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    if (this.cellEditor && this.cellEditor.destroy) {\n      this.cellEditor.destroy();\n      this.cellEditor = null;\n    }\n\n    if (this.cellRenderer && this.cellRenderer.destroy) {\n      this.cellRenderer.destroy();\n      this.cellRenderer = null;\n    }\n  };\n\n  CellComp.prototype.onLeftChanged = function () {\n    var left = this.modifyLeftForPrintLayout(this.getCellLeft());\n    this.getGui().style.left = left + 'px';\n  };\n\n  CellComp.prototype.modifyLeftForPrintLayout = function (leftPosition) {\n    if (!this.printLayout) {\n      return leftPosition;\n    }\n\n    if (this.column.getPinned() === column_1.Column.PINNED_LEFT) {\n      return leftPosition;\n    } else if (this.column.getPinned() === column_1.Column.PINNED_RIGHT) {\n      var leftWidth = this.beans.columnController.getPinnedLeftContainerWidth();\n      var bodyWidth = this.beans.columnController.getBodyContainerWidth();\n      return leftWidth + bodyWidth + leftPosition;\n    } else {\n      // is in body\n      var leftWidth = this.beans.columnController.getPinnedLeftContainerWidth();\n      return leftWidth + leftPosition;\n    }\n  };\n\n  CellComp.prototype.onWidthChanged = function () {\n    var width = this.getCellWidth();\n    this.getGui().style.width = width + 'px';\n  };\n\n  CellComp.prototype.getRangeClasses = function () {\n    var res = [];\n\n    if (!this.rangeSelectionEnabled) {\n      return res;\n    }\n\n    if (this.rangeCount !== 0) {\n      res.push('ag-cell-range-selected');\n    }\n\n    if (this.rangeCount === 1) {\n      res.push('ag-cell-range-selected-1');\n    }\n\n    if (this.rangeCount === 2) {\n      res.push('ag-cell-range-selected-2');\n    }\n\n    if (this.rangeCount === 3) {\n      res.push('ag-cell-range-selected-3');\n    }\n\n    if (this.rangeCount >= 4) {\n      res.push('ag-cell-range-selected-4');\n    }\n\n    return res;\n  };\n\n  CellComp.prototype.onRowIndexChanged = function () {\n    // when index changes, this influences items that need the index, so we update the\n    // grid cell so they are working off the new index.\n    this.createGridCellVo(); // when the index of the row changes, ie means the cell may have lost or gained focus\n\n    this.onCellFocused(); // check range selection\n\n    this.onRangeSelectionChanged();\n  };\n\n  CellComp.prototype.onRangeSelectionChanged = function () {\n    if (!this.beans.enterprise) {\n      return;\n    }\n\n    var newRangeCount = this.beans.rangeController.getCellRangeCount(this.gridCell);\n    var element = this.getGui();\n\n    if (this.rangeCount !== newRangeCount) {\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected', newRangeCount !== 0);\n\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-1', newRangeCount === 1);\n\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-2', newRangeCount === 2);\n\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-3', newRangeCount === 3);\n\n      utils_1._.addOrRemoveCssClass(element, 'ag-cell-range-selected-4', newRangeCount >= 4);\n\n      this.rangeCount = newRangeCount;\n    }\n  };\n\n  CellComp.prototype.onFirstRightPinnedChanged = function () {\n    var firstRightPinned = this.column.isFirstRightPinned();\n\n    if (this.firstRightPinned !== firstRightPinned) {\n      this.firstRightPinned = firstRightPinned;\n\n      utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-first-right-pinned', firstRightPinned);\n    }\n  };\n\n  CellComp.prototype.onLastLeftPinnedChanged = function () {\n    var lastLeftPinned = this.column.isLastLeftPinned();\n\n    if (this.lastLeftPinned !== lastLeftPinned) {\n      this.lastLeftPinned = lastLeftPinned;\n\n      utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-last-left-pinned', lastLeftPinned);\n    }\n  };\n\n  CellComp.prototype.populateTemplate = function () {\n    if (this.usingWrapper) {\n      this.eParentOfValue = this.getRefElement('eCellValue');\n      this.eCellWrapper = this.getRefElement('eCellWrapper');\n\n      if (this.includeRowDraggingComponent) {\n        this.addRowDragging();\n      }\n\n      if (this.includeSelectionComponent) {\n        this.addSelectionCheckbox();\n      }\n    } else {\n      this.eParentOfValue = this.getGui();\n    }\n  };\n\n  CellComp.prototype.addRowDragging = function () {\n    // row dragging only available in default row model\n    if (!this.beans.gridOptionsWrapper.isRowModelDefault()) {\n      utils_1._.doOnce(function () {\n        return console.warn('ag-Grid: row dragging is only allowed in the In Memory Row Model');\n      }, 'CellComp.addRowDragging');\n\n      return;\n    }\n\n    if (this.beans.gridOptionsWrapper.isPagination()) {\n      utils_1._.doOnce(function () {\n        return console.warn('ag-Grid: row dragging is not possible when doing pagination');\n      }, 'CellComp.addRowDragging');\n\n      return;\n    }\n\n    var rowDraggingComp = new rowDragComp_1.RowDragComp(this.rowNode, this.column, this.getValueToUse(), this.beans);\n    this.addFeature(this.beans.context, rowDraggingComp); // let visibleFunc = this.column.getColDef().checkboxSelection;\n    // visibleFunc = typeof visibleFunc === 'function' ? visibleFunc : null;\n    // cbSelectionComponent.init({rowNode: this.rowNode, column: this.column, visibleFunc: visibleFunc});\n    // put the checkbox in before the value\n\n    this.eCellWrapper.insertBefore(rowDraggingComp.getGui(), this.eParentOfValue);\n  };\n\n  CellComp.prototype.addSelectionCheckbox = function () {\n    var cbSelectionComponent = new checkboxSelectionComponent_1.CheckboxSelectionComponent();\n    this.beans.context.wireBean(cbSelectionComponent);\n    var visibleFunc = this.column.getColDef().checkboxSelection;\n    visibleFunc = typeof visibleFunc === 'function' ? visibleFunc : null;\n    cbSelectionComponent.init({\n      rowNode: this.rowNode,\n      column: this.column,\n      visibleFunc: visibleFunc\n    });\n    this.addDestroyFunc(function () {\n      return cbSelectionComponent.destroy();\n    }); // put the checkbox in before the value\n\n    this.eCellWrapper.insertBefore(cbSelectionComponent.getGui(), this.eParentOfValue);\n  };\n\n  CellComp.prototype.addDomData = function () {\n    var _this = this;\n\n    var element = this.getGui();\n    this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, this);\n    this.addDestroyFunc(function () {\n      return _this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, null);\n    });\n  };\n\n  CellComp.prototype.onCellFocused = function (event) {\n    var cellFocused = this.beans.focusedCellController.isCellFocused(this.gridCell); // see if we need to change the classes on this cell\n\n    if (cellFocused !== this.cellFocused) {\n      // if we are not doing cell selection, then the focus class does not change, all cells will\n      // stay with ag-cell-no-focus class\n      var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\n\n      if (doingFocusCss) {\n        utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-focus', cellFocused);\n\n        utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-cell-no-focus', !cellFocused);\n      }\n\n      this.cellFocused = cellFocused;\n    } // if this cell was just focused, see if we need to force browser focus, his can\n    // happen if focus is programmatically set.\n\n\n    if (cellFocused && event && event.forceBrowserFocus) {\n      this.getGui().focus();\n    } // if another cell was focused, and we are editing, then stop editing\n\n\n    var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\n\n    if (!cellFocused && !fullRowEdit && this.editingCell) {\n      this.stopRowOrCellEdit();\n    }\n  }; // pass in 'true' to cancel the editing.\n\n\n  CellComp.prototype.stopRowOrCellEdit = function (cancel) {\n    if (cancel === void 0) {\n      cancel = false;\n    }\n\n    if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n      this.rowComp.stopRowEditing(cancel);\n    } else {\n      this.stopEditing(cancel);\n    }\n  };\n\n  CellComp.prototype.stopEditing = function (cancel) {\n    if (cancel === void 0) {\n      cancel = false;\n    }\n\n    if (!this.editingCell) {\n      return;\n    } // if no cell editor, this means due to async, that the cell editor never got initialised,\n    // so we just carry on regardless as if the editing was never started.\n\n\n    if (!this.cellEditor) {\n      this.editingCell = false;\n      return;\n    }\n\n    var newValueExists = false;\n    var newValue;\n\n    if (!cancel) {\n      // also have another option here to cancel after editing, so for example user could have a popup editor and\n      // it is closed by user clicking outside the editor. then the editor will close automatically (with false\n      // passed above) and we need to see if the editor wants to accept the new value.\n      var userWantsToCancel = this.cellEditor.isCancelAfterEnd && this.cellEditor.isCancelAfterEnd();\n\n      if (!userWantsToCancel) {\n        newValue = this.cellEditor.getValue();\n        newValueExists = true;\n      }\n    } // it is important we set this after setValue() above, as otherwise the cell will flash\n    // when editing stops. the 'refresh' method checks editing, and doesn't refresh editing cells.\n    // thus it will skip the refresh on this cell until the end of this method where we call\n    // refresh directly and we suppress the flash.\n\n\n    this.editingCell = false;\n\n    if (this.cellEditor.destroy) {\n      this.cellEditor.destroy();\n    } // important to clear this out - as parts of the code will check for\n    // this to see if an async cellEditor has yet to be created\n\n\n    this.cellEditor = null;\n\n    if (this.cellEditorInPopup) {\n      this.hideEditorPopup();\n      this.hideEditorPopup = null;\n    } else {\n      utils_1._.removeAllChildren(this.getGui()); // put the cell back the way it was before editing\n\n\n      if (this.usingWrapper) {\n        // if wrapper, then put the wrapper back\n        this.getGui().appendChild(this.eCellWrapper);\n      } else {\n        // if cellRenderer, then put the gui back in. if the renderer has\n        // a refresh, it will be called. however if it doesn't, then later\n        // the renderer will be destroyed and a new one will be created.\n        if (this.cellRenderer) {\n          // we know it's a dom element (not a string) because we converted\n          // it after the gui was attached if it was a string.\n          var eCell = this.cellRendererGui; // can be null if cell was previously null / contained empty string,\n          // this will result in new value not being rendered.\n\n          if (eCell) {\n            this.getGui().appendChild(eCell);\n          }\n        }\n      }\n    }\n\n    this.setInlineEditingClass();\n\n    if (newValueExists) {\n      this.rowNode.setDataValue(this.column, newValue);\n      this.getValueAndFormat();\n    } // we suppress the flash, as it is not correct to flash the cell the user has finished editing,\n    // the user doesn't need to flash as they were the one who did the edit, the flash is pointless\n    // (as the flash is meant to draw the user to a change that they didn't manually do themselves).\n\n\n    this.refreshCell({\n      forceRefresh: true,\n      suppressFlash: true\n    });\n    var event = this.createEvent(null, events_1.Events.EVENT_CELL_EDITING_STOPPED);\n    this.beans.eventService.dispatchEvent(event);\n  };\n\n  CellComp.DOM_DATA_KEY_CELL_COMP = 'cellComp';\n  return CellComp;\n}(component_1.Component);\n\nexports.CellComp = CellComp;","map":null,"metadata":{},"sourceType":"script"}