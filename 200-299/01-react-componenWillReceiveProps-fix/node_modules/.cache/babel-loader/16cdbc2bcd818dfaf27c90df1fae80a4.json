{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v19.1.4\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar context_1 = require(\"../../context/context\");\n\nvar gridOptionsWrapper_1 = require(\"../../gridOptionsWrapper\");\n\nvar utils_1 = require(\"../../utils\");\n\nvar componentProvider_1 = require(\"./componentProvider\");\n\nvar agComponentUtils_1 = require(\"./agComponentUtils\");\n\nvar componentMetadataProvider_1 = require(\"./componentMetadataProvider\");\n\nvar ComponentType;\n\n(function (ComponentType) {\n  ComponentType[ComponentType[\"AG_GRID\"] = 0] = \"AG_GRID\";\n  ComponentType[ComponentType[\"FRAMEWORK\"] = 1] = \"FRAMEWORK\";\n})(ComponentType = exports.ComponentType || (exports.ComponentType = {}));\n\nvar ComponentSource;\n\n(function (ComponentSource) {\n  ComponentSource[ComponentSource[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  ComponentSource[ComponentSource[\"REGISTERED_BY_NAME\"] = 1] = \"REGISTERED_BY_NAME\";\n  ComponentSource[ComponentSource[\"HARDCODED\"] = 2] = \"HARDCODED\";\n})(ComponentSource = exports.ComponentSource || (exports.ComponentSource = {}));\n\nvar ComponentResolver =\n/** @class */\nfunction () {\n  function ComponentResolver() {}\n  /**\n   * This method returns the underlying representation of the component to be created. ie for Javascript the\n   * underlying function where we should be calling new into. In case of the frameworks, the framework class\n   * object that represents the component to be created.\n   *\n   * This method is handy for different reasons, for example if you want to check if a component has a particular\n   * method implemented without having to create the component, just by inspecting the source component\n   *\n   * It takes\n   *  @param holder: This is the context for which this component needs to be created, it can be gridOptions\n   *      (global) or columnDef mostly.\n   *  @param propertyName: The name of the property used in ag-grid as a convention to refer to the component, it can be:\n   *      'floatingFilter', 'cellRenderer', is used to find if the user is specifying a custom component\n   *  @param dynamicComponentParams: Params to be passed to the dynamic component function in case it needs to be\n   *      invoked\n   *  @param defaultComponentName: The name of the component to load if there is no component specified\n   */\n\n\n  ComponentResolver.prototype.getComponentToUse = function (holder, propertyName, dynamicComponentParams, defaultComponentName) {\n    /**\n     * There are five things that can happen when resolving a component.\n     *  a) HardcodedFwComponent: That holder[propertyName]Framework has associated a Framework native component\n     *  b) HardcodedJsComponent: That holder[propertyName] has associate a JS component\n     *  c) hardcodedJsFunction: That holder[propertyName] has associate a JS function\n     *  d) hardcodedNameComponent: That holder[propertyName] has associate a string that represents a component to load\n     *  e) That none of the three previous are specified, then we need to use the DefaultRegisteredComponent\n     */\n    var hardcodedNameComponent = null;\n    var HardcodedJsComponent = null;\n    var hardcodedJsFunction = null;\n    var HardcodedFwComponent = null;\n    var dynamicComponentFn;\n\n    if (holder != null) {\n      var componentPropertyValue = holder[propertyName];\n\n      if (componentPropertyValue != null) {\n        if (typeof componentPropertyValue === 'string') {\n          hardcodedNameComponent = componentPropertyValue;\n        } else if (this.agComponentUtils.doesImplementIComponent(componentPropertyValue)) {\n          HardcodedJsComponent = componentPropertyValue;\n        } else {\n          hardcodedJsFunction = componentPropertyValue;\n        }\n      }\n\n      HardcodedFwComponent = holder[propertyName + \"Framework\"];\n      dynamicComponentFn = holder[propertyName + \"Selector\"];\n    }\n    /**\n     * Since we allow many types of flavors for specifying the components, let's make sure this is not an illegal\n     * combination\n     */\n\n\n    if (HardcodedJsComponent && HardcodedFwComponent || hardcodedNameComponent && HardcodedFwComponent || hardcodedJsFunction && HardcodedFwComponent) {\n      throw Error(\"ag-grid: you are trying to specify: \" + propertyName + \" twice as a component.\");\n    }\n\n    if (HardcodedFwComponent && !this.frameworkComponentWrapper) {\n      throw Error(\"ag-grid: you are specifying a framework component but you are not using a framework version of ag-grid for : \" + propertyName);\n    }\n\n    if (dynamicComponentFn && (hardcodedNameComponent || HardcodedJsComponent || hardcodedJsFunction || HardcodedFwComponent)) {\n      throw Error(\"ag-grid: you can't specify both, the selector and the component of ag-grid for : \" + propertyName);\n    }\n    /**\n     * At this stage we are guaranteed to either have,\n     * DEPRECATED\n     * - A unique HardcodedFwComponent\n     * - A unique HardcodedJsComponent\n     * - A unique hardcodedJsFunction\n     * BY NAME- FAVOURED APPROACH\n     * - A unique hardcodedNameComponent\n     * - None of the previous, hence we revert to: RegisteredComponent\n     */\n\n\n    if (HardcodedFwComponent) {\n      // console.warn(`ag-grid: Since version 12.1.0 specifying a component directly is deprecated, you should register the component by name`);\n      // console.warn(`${HardcodedFwComponent}`);\n      return {\n        type: ComponentType.FRAMEWORK,\n        component: HardcodedFwComponent,\n        source: ComponentSource.HARDCODED,\n        dynamicParams: null\n      };\n    }\n\n    if (HardcodedJsComponent) {\n      // console.warn(`ag-grid: Since version 12.1.0 specifying a component directly is deprecated, you should register the component by name`);\n      // console.warn(`${HardcodedJsComponent}`);\n      return {\n        type: ComponentType.AG_GRID,\n        component: HardcodedJsComponent,\n        source: ComponentSource.HARDCODED,\n        dynamicParams: null\n      };\n    }\n\n    if (hardcodedJsFunction) {\n      // console.warn(`ag-grid: Since version 12.1.0 specifying a function directly is deprecated, you should register the component by name`);\n      // console.warn(`${hardcodedJsFunction}`);\n      return this.agComponentUtils.adaptFunction(propertyName, hardcodedJsFunction, ComponentType.AG_GRID, ComponentSource.HARDCODED);\n    }\n\n    if (dynamicComponentFn) {\n      var dynamicComponentDef = dynamicComponentFn(dynamicComponentParams);\n\n      if (dynamicComponentDef != null) {\n        if (dynamicComponentDef.component == null) {\n          dynamicComponentDef.component = defaultComponentName;\n        }\n\n        var dynamicComponent = this.resolveByName(propertyName, dynamicComponentDef.component);\n        return utils_1._.assign(dynamicComponent, {\n          dynamicParams: dynamicComponentDef.params\n        });\n      }\n    } //^^^^^ABOVE DEPRECATED - AT THIS POINT WE ARE RESOLVING BY NAME\n\n\n    var componentNameToUse;\n\n    if (hardcodedNameComponent) {\n      componentNameToUse = hardcodedNameComponent;\n    } else {\n      componentNameToUse = defaultComponentName;\n    }\n\n    return componentNameToUse == null ? null : this.resolveByName(propertyName, componentNameToUse);\n  };\n\n  ComponentResolver.prototype.resolveByName = function (propertyName, componentNameOpt) {\n    var componentName = componentNameOpt != null ? componentNameOpt : propertyName;\n    var registeredComponent = this.componentProvider.retrieve(componentName);\n    if (registeredComponent == null) return null; //If it is a FW it has to be registered as a component\n\n    if (registeredComponent.type == ComponentType.FRAMEWORK) {\n      return {\n        component: registeredComponent.component,\n        type: ComponentType.FRAMEWORK,\n        source: ComponentSource.REGISTERED_BY_NAME,\n        dynamicParams: null\n      };\n    } //If it is JS it may be a function or a component\n\n\n    if (this.agComponentUtils.doesImplementIComponent(registeredComponent.component)) {\n      return {\n        component: registeredComponent.component,\n        type: ComponentType.AG_GRID,\n        source: registeredComponent.source == componentProvider_1.RegisteredComponentSource.REGISTERED ? ComponentSource.REGISTERED_BY_NAME : ComponentSource.DEFAULT,\n        dynamicParams: null\n      };\n    } // This is a function\n\n\n    return this.agComponentUtils.adaptFunction(propertyName, registeredComponent.component, registeredComponent.type, registeredComponent.source == componentProvider_1.RegisteredComponentSource.REGISTERED ? ComponentSource.REGISTERED_BY_NAME : ComponentSource.DEFAULT);\n  };\n  /**\n   * Useful to check what would be the resultant params for a given object\n   *  @param holder: This is the context for which this component needs to be created, it can be gridOptions\n   *      (global) or columnDef mostly.\n   *  @param propertyName: The name of the property used in ag-grid as a convention to refer to the component, it can be:\n   *      'floatingFilter', 'cellRenderer', is used to find if the user is specifying a custom component\n   *  @param agGridParams: Params to be passed to the component and passed by ag-Grid. This will get merged with any params\n   *      specified by the user in the configuration\n   * @returns {any} It merges the user agGridParams with the actual params specified by the user.\n   */\n\n\n  ComponentResolver.prototype.mergeParams = function (holder, propertyName, agGridParams, dynamicCustomParams, dynamicParams) {\n    if (dynamicParams === void 0) {\n      dynamicParams = null;\n    }\n\n    var customParamsRaw = holder ? holder[propertyName + \"Params\"] : null;\n    var finalParams = {};\n\n    utils_1._.mergeDeep(finalParams, agGridParams);\n\n    if (customParamsRaw != null) {\n      var customParams = utils_1._.cloneObject(finalParams);\n\n      if (typeof customParamsRaw === 'function') {\n        utils_1._.mergeDeep(customParams, dynamicCustomParams);\n\n        customParams = customParamsRaw(customParams);\n      } else {\n        customParams = customParamsRaw;\n      }\n\n      utils_1._.mergeDeep(finalParams, customParams);\n    }\n\n    utils_1._.mergeDeep(finalParams, dynamicParams);\n\n    if (!finalParams.api) {\n      finalParams.api = this.gridOptions.api;\n    }\n\n    return finalParams;\n  };\n  /**\n   * This method creates a component given everything needed to guess what sort of component needs to be instantiated\n   * It takes\n   *  @param holderOpt: This is the context for which this component needs to be created, it can be gridOptions\n   *      (global) or columnDef mostly.\n   *  @param agGridParams: Params to be passed to the component and passed by ag-Grid. This will get merged with any params\n   *      specified by the user in the configuration\n   *  @param propertyName: The name of the property used in ag-grid as a convention to refer to the component, it can be:\n   *      'floatingFilter', 'cellRenderer', is used to find if the user is specifying a custom component\n   *  @param dynamicComponentParams: Params to be passed to the dynamic component function in case it needs to be\n   *      invoked\n   *  @param defaultComponentName: The actual name of the component to instantiate, this is usually the same as propertyName, but in\n   *      some cases is not, like floatingFilter, if it is the same is not necessary to specify\n   *  @param mandatory: Handy method to tell if this should return a component ALWAYS. if that is the case, but there is no\n   *      component found, it throws an error, by default all components are MANDATORY\n   *  @param customInitParamsCb: A chance to customise the params passed to the init method. It receives what the current\n   *  params are and the component that init is about to get called for\n   */\n\n\n  ComponentResolver.prototype.createAgGridComponent = function (holderOpt, agGridParams, propertyName, dynamicComponentParams, defaultComponentName, mandatory, customInitParamsCb) {\n    if (mandatory === void 0) {\n      mandatory = true;\n    }\n\n    var holder = holderOpt == null ? this.gridOptions : holderOpt; //Create the component instance\n\n    var componentAndParams = this.newAgGridComponent(holder, propertyName, dynamicComponentParams, defaultComponentName, mandatory);\n    if (!componentAndParams) return null; // Wire the component and call the init method with the correct params\n\n    var finalParams = this.mergeParams(holder, propertyName, agGridParams, dynamicComponentParams, componentAndParams[1]); // a temporary fix for AG-1574\n    // AG-1715 raised to do a wider ranging refactor to improve this\n\n    finalParams.agGridReact = this.context.getBean('agGridReact') ? utils_1._.cloneObject(this.context.getBean('agGridReact')) : {}; // AG-1716 - directly related to AG-1574 and AG-1715\n\n    finalParams.frameworkComponentWrapper = this.context.getBean('frameworkComponentWrapper') ? this.context.getBean('frameworkComponentWrapper') : {};\n    var deferredInit = this.initialiseComponent(componentAndParams[0], finalParams, customInitParamsCb);\n\n    if (deferredInit == null) {\n      return utils_1.Promise.resolve(componentAndParams[0]);\n    } else {\n      var asPromise = deferredInit;\n      return asPromise.map(function (notRelevant) {\n        return componentAndParams[0];\n      });\n    }\n  };\n  /**\n   * This method creates a component given everything needed to guess what sort of component needs to be instantiated\n   * It takes\n   *  @param clazz: The class to instantiate,\n   *  @param agGridParams: Params to be passed to the component and passed by ag-Grid. This will get merged with any params\n   *      specified by the user in the configuration\n   *  @param customInitParamsCb: A chance to customise the params passed to the init method. It receives what the current\n   *  params are and the component that init is about to get called for\n   */\n\n\n  ComponentResolver.prototype.createInternalAgGridComponent = function (clazz, agGridParams, customInitParamsCb) {\n    var internalComponent = new clazz();\n    this.initialiseComponent(internalComponent, agGridParams, customInitParamsCb);\n    return internalComponent;\n  };\n\n  ComponentResolver.prototype.newAgGridComponent = function (holder, propertyName, dynamicComponentParams, defaultComponentName, mandatory) {\n    if (mandatory === void 0) {\n      mandatory = true;\n    }\n\n    var componentToUse = this.getComponentToUse(holder, propertyName, dynamicComponentParams, defaultComponentName);\n\n    if (!componentToUse || !componentToUse.component) {\n      if (mandatory) {\n        console.error(\"Error creating component \" + propertyName + \"=>\" + defaultComponentName);\n      }\n\n      return null;\n    }\n\n    if (componentToUse.type === ComponentType.AG_GRID) {\n      return [new componentToUse.component(), componentToUse.dynamicParams];\n    } //Using framework component\n\n\n    var FrameworkComponentRaw = componentToUse.component;\n    var thisComponentConfig = this.componentMetadataProvider.retrieve(propertyName);\n    return [this.frameworkComponentWrapper.wrap(FrameworkComponentRaw, thisComponentConfig.mandatoryMethodList, thisComponentConfig.optionalMethodList, defaultComponentName), componentToUse.dynamicParams];\n  };\n\n  ComponentResolver.prototype.initialiseComponent = function (component, agGridParams, customInitParamsCb) {\n    this.context.wireBean(component);\n    if (component.init == null) return;\n\n    if (customInitParamsCb == null) {\n      return component.init(agGridParams);\n    } else {\n      return component.init(customInitParamsCb(agGridParams, component));\n    }\n  };\n\n  __decorate([context_1.Autowired(\"gridOptions\"), __metadata(\"design:type\", Object)], ComponentResolver.prototype, \"gridOptions\", void 0);\n\n  __decorate([context_1.Autowired(\"gridOptionsWrapper\"), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], ComponentResolver.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.Autowired(\"context\"), __metadata(\"design:type\", context_1.Context)], ComponentResolver.prototype, \"context\", void 0);\n\n  __decorate([context_1.Autowired(\"agComponentUtils\"), __metadata(\"design:type\", agComponentUtils_1.AgComponentUtils)], ComponentResolver.prototype, \"agComponentUtils\", void 0);\n\n  __decorate([context_1.Autowired(\"componentMetadataProvider\"), __metadata(\"design:type\", componentMetadataProvider_1.ComponentMetadataProvider)], ComponentResolver.prototype, \"componentMetadataProvider\", void 0);\n\n  __decorate([context_1.Autowired(\"componentProvider\"), __metadata(\"design:type\", componentProvider_1.ComponentProvider)], ComponentResolver.prototype, \"componentProvider\", void 0);\n\n  __decorate([context_1.Optional(\"frameworkComponentWrapper\"), __metadata(\"design:type\", Object)], ComponentResolver.prototype, \"frameworkComponentWrapper\", void 0);\n\n  ComponentResolver = __decorate([context_1.Bean('componentResolver')], ComponentResolver);\n  return ComponentResolver;\n}();\n\nexports.ComponentResolver = ComponentResolver;","map":null,"metadata":{},"sourceType":"script"}